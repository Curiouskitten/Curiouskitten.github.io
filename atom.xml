<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柒仔的学习栈</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-30T09:04:36.187Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>柒仔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DDoS技术简述</title>
    <link href="http://example.com/2023/03/29/DDoS%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/"/>
    <id>http://example.com/2023/03/29/DDoS%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/</id>
    <published>2023-03-29T15:22:48.000Z</published>
    <updated>2023-03-30T09:04:36.187Z</updated>
    
    <content type="html"><![CDATA[<p>没有绝对安全的系统，每一个所谓安全的网络系统，最终都有一个不安全的隐患</p><p>DDoS：分布式拒绝服务（攻击）<br>DDoS攻击的手法暴力且直接，但破坏力惊人，至今也缺乏彻底的根治方法。</p><p>内容源：<a href="https://www.bilibili.com/video/BV1KQ4y117nq/">https://www.bilibili.com/video/BV1KQ4y117nq/</a></p><h2 id="历史案例"><a href="#历史案例" class="headerlink" title="历史案例"></a>历史案例</h2><p>1996-09-06，美国纽约，著名的互联网服务商Panix的服务器受到每秒高达150次的异常连续攻击，导致服务器疲于应付这些非法流量，而拒绝了正常用户的合法请求。这是目前大家比较认可的历史上第一次DoS攻击。<br>DoS： Denial of Service，拒绝服务，即通过占用网络服务资源让它应接不暇，从而拒绝正常的业务流量的一种网络攻击方式。<br>DDoS： Distributed Denial of service， DoS攻击的分布式版本，俗称“群殴”。<br><img src="DDoS_attack.PNG" alt="DDoS_attack"></p><p>单台设备的攻击能力有限，治理起来也比较容易，但是当成千上万个设备组成一个网络同时攻击目标发起DoS攻击时无异于一场灾难。<br>发起攻击的网路一般称之为：僵尸网络（BotNet）<br>每个僵尸可以是一台个人电脑，可以是一台服务器，甚至可以是一部智能手机。为了得到这样的一个僵尸网络则是八仙过海，各显神通。<br>或因为穷或因为技术过硬的人士利用木马，蠕虫，后门等恶意程序感染大量设备形成僵尸网络。而富人则比较轻松，通过某些渠道直接花钱就可以购买到，理论上，花的钱越多得到的僵尸网络规模就越大，攻击力就越强。</p><p>1999-08-17，美国明尼苏达大学的服务器在至少200多台设备的DDoS攻击之下，服务被迫终止了2天。而这200多台发起攻击的蛇别都是在不知情的情况下被感染，成为了僵尸网络中的一员。在通过IP追踪并让设备停止攻击后，问题依旧没能完全解决，因为不断的有新的攻击设备加入进来。</p><p>DDoS攻击和其他利用程序漏洞攻击的阴谋不同，这种直接粗暴的方式算是一种阳谋，大家都知道是怎么发生的，但又无可奈何。</p><h2 id="互联网（internet）通讯过程"><a href="#互联网（internet）通讯过程" class="headerlink" title="互联网（internet）通讯过程"></a>互联网（internet）通讯过程</h2><p>为了了解DDoS攻击手段的巧妙，需要先了解一点互联网的工作方式。<br>一次网络访问的过程简化来看，是这样的：<br><img src="c_spost.PNG" alt="c_spost"></p><p>客户端通过网络线路向远程的服务器请求内容，服务器按照客户端的需求或查询或计算出相应的数据，再通过网络线路返送给客户端。这个数据在两端的行为和传统的邮递过程十分相像。<br>传统的邮递靠的是邮政系统，而现代互联网中的数据流转则是依靠以TCP/IP协议为核心的通信系统。TCP/IP的参考模型是一个4层结构（详细可以去看下blog中计算机网络基础知识这篇文章）<br>我们可以借助传统的邮递系统做个类比。<br><img src="TCP_IP4.PNG" alt="TCP_IP4"></p><p>写信的时候，大家一般会遵从约定的格式。比如先写对方的称呼，加个冒号，再写正文。结尾写上“此致敬礼”，最后写上署名和日期。<br>这类似于4层结构中的应用层规定的一些数据内容的协议规则。比如我们网上冲浪时常用到的http协议就属于这一层。<br><img src="letter_form.PNG" alt="letter_form"></p><p>写完信以后，我们可以做一个标记，比如沾上一根鸡毛，或盖上一个红戳。对方会根据这些标记决定如何回复。要不要加急，要不要确认一下对方的身份等。这类似于4层结构中的传输层。规定了数据的传输方式。比如这一层中大家熟悉的TCP协议，为了保证通信的可靠性，需要先经历3次握手再发起数据传输。实际上对于一次可靠的通信过程，事先的沟通是很必要的。这在日常生活中很常见。<br><img src="letter_transport.PNG" alt="letter_transport"></p><p>以三国演义中孙策对战太史慈为例：<br>    “谁是孙策”<br>    “你是何人”<br>    “我是东莱太史慈，前来捉拿孙策”<br>    “你就是太史慈，我正要会你”<br>    “你是何人”<br>    “我是孙策”<br>为了保证打架前没有搞错对象，孙策和太史慈反复确认了对方的身份之后才开始动手，TCP协议的3次握手做到了这一点。换句话说，在正式写信说正事儿之前，先发送3封确定彼此的信建立一种可靠的连接。<br>第一次，在TCP协议的信件上有几个关键的字段，在发起TCP连接时，我方先把SYN设置为1，ACK设置为0，再选择一个顺序号x，然后发出去。<br><img src="clientSendSYN.PNG" alt="clientSendSYN"></p><p>第二次，对方收到后回复一封信，把SYN设置为1，ACK设置为1，确认号设置为x+1，同时选择一个顺序号Y，返回我方。<br><img src="TCP_synService.PNG" alt="TCP_synService"></p><p>第三次，我方收到回信后，把SYN设置为0，ACK设置为1，确认号设置为y+1，顺序号设置为x+1，再次发送出去。<br><img src="TCP_synclient.PNG" alt="TCP_synclient"></p><p>如此一个TCP连接就建立起来了。接下来就可以发送用户数据了。因为3次握手的存在，通讯更加的可靠，类似即时通信这样的软件，多采用TCP协议在客户端服务器之间建立一个连接通道。而这一层中还有一个著名的UDP协议。它没有这么麻烦，不需要反复握手建立连接，直接把数据投递出去，也不管对方收到没有。所以这是一种不可靠的协议，但是因为简单所以信息传递的快，多用于在线视频，音频的实现中。<br><img src="tcp_udp.PNG" alt="tcp_udp"></p><p>而用来装信件（数据）的信封类似于4层结构中的网络层，主要规定了双方地址的编码规则，这一层采用的是IP协议。即“设备IP地址”<br>而一封信的投递最终依靠的是邮局。邮局把信件打包装车之后，根据收件地址把信件投递到目的地，这一层对应着4层结构中的子网层，是信息传递的物理载体，比如：以太网（当下主要的），卫星网等等。<br>这4层结构从应用层到子网层，数据按照不同的协议不断的打包，到达目的地之后则刚好是相反的拆包过程而最终被目标接收。可以看出来其中最为核心的是互联网层中的IP协议。只要是按照IP协议封装数据都可以被发送。不论是以太网，卫星网等还是其他物理实现的子网。你只要按照新风尚的格式写好收发地址。装入的信件就可以被投递到目的地。不论是走陆运，空运还是海运，IP协议让不同子网络互联了起来。<br><img src="post_tcp.PNG" alt="post_tcp"><br><img src="subnet.PNG" alt="subnet"></p><h2 id="DDoS攻击手段"><a href="#DDoS攻击手段" class="headerlink" title="DDoS攻击手段"></a>DDoS攻击手段</h2><p>综上所述，从数据离开到最终到达这一路，几乎每一个地方都有被DDoS攻击的机会。<br>比如：霸占服务器的网络带宽资源<br><img src="ICMP_transport.PNG" alt="ICMP_transport"></p><p>只需要向一台服务器发送大量的IP协议数据包。就可以慢慢的消耗掉对方的网络带宽。比如：用耳熟能详的ping工具就可以发起一次攻击。ping产生的是ICMP协议包，ICMP是IP协议中用来进行差错控制的一个补充，本质上还是一个IP包。这种攻击方式也称之为ICMP洪水（ICMP flood）。这种手段类似于我们不断的给某人投递信件，写了什么不重要，重要的是让信件多到邮递员在对方家门口排起长队，从而打断正常的信件收发。<br>同样的思路，还可以发送传输层的UDP协议包。发起一次UDP洪水攻击（UDP flood），当然这里有个问题：会暴露攻击设备的IP地址，导致禁封。所以攻击者一般会通过伪造IP地址隐藏自己。<br>比如：张三给李四写信，却把发件地址写成王五，这样即使是一封祖安问候信，李四也只能迁怒于王五，或者干脆写一个不存在的地址，让李四无处泄愤。但出于隐藏自己的目的，人们发明了一个更有趣的攻击方式：反射攻击<br><img src="reflection_attack.PNG" alt="reflection_attack"></p><p>既然可以伪造IP，那么就不必拘泥于伪造发件人的身份，同样可以伪造收件人的身份达到借刀杀人的效果。我们把信封上的发件地址改为攻击目标的IP地址，收件地址设置为互联网上的大量第三方机器。从而把数据发送到这些第三方机器上，这些机器在接收到数据后，回复数据就会涌入发件地址指向的攻击目标。这些第三方机器也被称之为”反射器“。这有点像把别人的号码挂在一些网站上，然后记住被不明真相的推销员呼死。很损，但有效。反射攻击更难追踪来源，但更厉害的是，人们在此基础上又发明了一种把攻击流量放大以达到更强攻击效果的手段：放大攻击。</p><p><img src="DNSservice.PNG" alt="DNSservice"><br>比如：DNS服务器是一种用来把域名解析为IP地址的设备。我们在浏览器中输入”<a href="http://www.bilibili.com/">www.bilibili.com</a> “这样的域名地址，实际上需要先查询DNS服务器，获得这个域名对应的IP地址，再用IP地址访问B站的服务器。同时DNS查询通常使用UDP这个不用验证来源的传输协议，综合来看，DNS服务器就是一个很好的放大器。因为一次DNS查询请求，返回数据往往大于请求数据。这里有一个“带宽放大因子”BAF的概念。在DNS查询中，一般60byte的请求数据可以获得将近3000byte的返回数据。那么BAF=3000/60=50，即产生50倍的放大效果。如果我们让攻击者不断的去对DNS服务器发起查询请求，并把源地址伪造为攻击目标的IP，那么这样的反射攻击就会产生50倍的流量放大效果。<br><img src="DNSenlargeAttack.PNG" alt="DNSenlargeAttack"></p><p>除了对目标带宽资源进行霸占以达到DDoS攻击效果外，因为TCP协议中有连接的概念，所以还可以攻击服务器的连接资源。服务器和客户端每次建立一个TCP连接时，需要建立3次握手将连接信息放入连接表中维护。而连接表的大小是有限的，我们可以让发起攻击的设备直接发起大量的TCP连接从而沾满服务器的这个连接表，而无法响应后续的TCP连接请求。从而达到DDoS攻击的效果。这种直接的方式称之为TCP洪水（TCPflood）。但因为有3次握手的存在，所以TCP洪水无法通过伪造IP隐藏自己。因为虚假的IP无法做出正确的回应导致无法建立连接。但是可以在建立连接的3次握手本身上做文章。</p><p>比如：只发送SYN不进行后续的回答这样“虚晃一枪”的SYN洪水。这样做的好处是，如果不回答攻击者的SYN+ACK数据，考虑到可能是网络环境问题，TCP中的重传机制会使得攻击目标多次尝试发送SYN+ACK直到超时。受害者不断的向攻击者发送SYN+ACK，比如重传10次，那这就相当于每攻击目标一次，对方就会回复10次。“杀敌1k自损1w”也不过如此。所以SYN洪水攻击一般都会伪造IP或不存在在的地址，让受害者拔剑四顾心茫然。抑或者是某个真实的倒霉蛋IP，将祸水东引。<br>同样的思路，在TCP协议中也可以通过反射发起攻击。向各个反射器发送SYN，将发件地址伪造成攻击目标，这样大量的SYN+ACK数据将涌入攻击目标。当然这种攻击方式因为无法在目标上建立连接。所以还是在攻击带宽。<br><img src="SYNreflection.PNG" alt="SYNreflection"></p><p>针对TCP协议还有一种巧妙的攻击手段：RST洪水攻击<br><img src="PST_flow.PNG" alt="PST_flow"></p><p>在TCP协议中，一般用4次挥手结束连接。但是为了防止异常，一方可以发送一个RST数据强制切断连接。让攻击设备不断的尝试伪造各种IP地址并发送RST数据进行“盲打”，一旦IP和其他的一些配置和某个正常用户的匹配上。就能够切断正常用户和服务器之间的连接。这种攻击方式更针对用户。<br><img src="" alt="routA"></p><p>比如：在一场网络游戏对战中，在获悉对手的IP地址后，就可以不断切段对方的游戏设备和服务器的连接以干扰游戏。<br>不论是利用IP，UDP还是TCP协议攻击，针对的都是网络和连接资源。还有一种直接针对服务内部资源的攻击方式：消耗目标的计算和IO（资源）</p><p><img src="httpAttack.PNG" alt="httpAttack"><br>基于上述4层结构，作为第五层的用户，一般在网络冲浪时接触的都是应用层中像http这样的协议。所以我们可以对一个站点发起http洪水攻击。</p><p><img src="distributedhttpflow.PNG" alt="distributedhttpflow"><br>比如站点的搜索功能。不断的生成大量的关键词送入查询地址，因为http请求作为用户直接发起的设计具体业务的请求，服务器在收到请求和需要进行像数据库查询这样的IO操作。所以这样的攻击手法会对目标产生更大的消耗。当然http洪水攻击有个问题：不能伪造IP地址。<br>因为http协议是基于TCP协议的。需要经历3次握手。所以常见的方法是借助网络代理主机得到不同的真实IP发起攻击。这对于一次资金充足，有计划，有组织的攻击来说并不是一件难事。DDoS攻击还有一些其他方式，不再一一例举。</p><h2 id="DDoS的治理和缓解方法"><a href="#DDoS的治理和缓解方法" class="headerlink" title="DDoS的治理和缓解方法"></a>DDoS的治理和缓解方法</h2><p>所谓有攻就有防。应对DDoS攻击的方法，主要有两个方向：</p><ol><li>激进的【手术治疗】</li><li>稳妥的【保守治理】<br>捣毁僵尸网络并让用户做好个人防护，避免感染成为僵尸设备是一种很好的方法。但是这是需要长期持续进行的方案。两个典型的技术层面上治理DDoS攻击的方法。<br>从DDoS的攻击原理上我们可以看出来，伪造IP地址是DDoS攻击的核心技术之一，一旦攻击者无法伪造IP地址，那就形同冢中枯骨，强弩之末。而治理伪造IP的方法并不复杂。<br>现代互联网的下游，也就是用户设备接入的这一端。设备通过路由（或多个路由网关）接入互联网提供商（ISP），所以只要让路由设备检测IP，把源地址IP不属于本路由所网段的数据都过滤掉，这样试图伪造IP的流量就无法发出。<br>还有一个稍微复杂点的分布式过滤方案。庞大的互联网中不同的网段与奥路由把彼此连接，一个数据从甲发送到乙，它的IP可以伪造成丙，但是它所经过真实线路则不可能作假。<br><img src="distributeflowRout.PNG" alt="distributeflowRout"></li></ol><p>换句话说。从丙–&gt;乙的数据不可能经过路由A，但这个伪造IP的数据从甲–&gt;乙却经过了A。如果路由能根据IP地址的路径逻辑检测出矛盾，那么就会过滤掉这样的流量，从而消灭伪造IP的伎俩。<br>当然，一个涉及到用户，服务商，设备上，甚至是监管部门等多方的技术方案，那就不能只是一个技术问题。处于商业上投入产出的考虑，往往是木已成舟，积重难返。这两种方案很难被执行。只有有一定影响力的大型企业和机构才能撬动这种涉及全球的多方合作。对于中小企业，甚至是刚起步的创业者来说并不现实。<br>所以人们提出了一些大家都能承担的起的（也不一定）缓解DDoS攻击的保守治疗方案。<br>当前两种使用比较多的方法<br>DDoS攻击的可怕之处在于第一个D-分布式（Distributed）。<br>当一个僵尸网络上对目标发起进攻时，很难处理这些来自四面八方的流量。但所谓师夷长技以制夷，敌人可以群起而攻之，那作为守法公民，我们又何尝不能联合起来，把一个网络服务的流量分散到不同的地方，从而稀释流量。<br>比如目前各个站点普遍采用的CDN技术。把一些相对静态的资源作为缓存分发给各个CDN节点。用户在请求的时候从最近的节点返回，总这样就在一定程度上缓解了DDoS攻击。当然，CDN的缓解作用比较有限。<br><img src="CDNdilution.PNG" alt="CDNdilution"></p><p>有一种目前比较主流的并有一些厂商专门为此开发产品的方案，流量清洗。我们在服务器前架设一台流量清洗设备。<br><img src="flow_cleaning.PNG" alt="flow_cleaning"></p><p>这个设备就像是一个身高马大的保镖和秘书，帮我们对抗DDoS流量。比如，面对TCP协议的SYN洪流DDoS攻击，客户端发起的SYN先经过清洗设备，由清洗设备回复SYN+ACK，如果对方答应了，那说明是正常的流量。清洗设备再把本次连接交给后方的服务器正常通讯。如果对方不应答，清洗设备该重试重试，超时之后就断开连接。但因为清洗设备人高马大，作为专门应对攻击的角色，对连接设备做了极大的专门的优化，能应对海量的连接请求。所以攻击者想要通过SYN flood打垮它非常困难。</p><p>再比如威胁极大的http flood攻击。正常来说，一个http请求很难用传统的方式检测出是恶意流量还是正常流量。而清洗设备往往会提供专业的流量清洗平台，这些专业做流量清洗的服务商通过多年和DDoS攻击的对抗，积累了大量的经验和技术。比如：由于http无法伪造IP地址，所以通过多年的数据积累建立IP信用库。从那些经常发起攻击的臭名昭著的IP发来的流量就会被过滤掉。<br>再比如，恶意流量由于是通过程序自动发出而不是人类操作，所以利用算法对流量进行模式识别就可以被检测出来。</p><p>但无论怎样，DDoS作为一种历史悠久且破坏能力巨大的黑客攻击手段，时至今日还是无法彻底被解决。<br>做好防护，保持警惕</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;没有绝对安全的系统，每一个所谓安全的网络系统，最终都有一个不安全的隐患&lt;/p&gt;
&lt;p&gt;DDoS：分布式拒绝服务（攻击）&lt;br&gt;DDoS攻击的手法暴力且直接，但破坏力惊人，至今也缺乏彻底的根治方法。&lt;/p&gt;
&lt;p&gt;内容源：&lt;a href=&quot;https://www.bilibi</summary>
      
    
    
    
    
    <category term="网络安全 DDoS攻击" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-DDoS%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>python接口自动化框架</title>
    <link href="http://example.com/2022/10/23/auto-api/"/>
    <id>http://example.com/2022/10/23/auto-api/</id>
    <published>2022-10-23T07:20:54.000Z</published>
    <updated>2023-03-12T04:27:38.983Z</updated>
    
    <content type="html"><![CDATA[<p>基于Unittest的接口自动化测试框架，可直接套用，根据实际业务做内容修改</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="catalogue.jpg" alt="catalogue_of_frame"></p><h2 id="各模块介绍"><a href="#各模块介绍" class="headerlink" title="各模块介绍"></a>各模块介绍</h2><h3 id="Http请求能力封装-http-request-py"><a href="#Http请求能力封装-http-request-py" class="headerlink" title="Http请求能力封装-http_request.py"></a>Http请求能力封装-http_request.py</h3><p>引用三方库requests<br>若本地没有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_http_requests(url, method, **kwargs):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    发送http请求</span></span><br><span class="line"><span class="string">    :param url: 请求url</span></span><br><span class="line"><span class="string">    :param method: 请求方法</span></span><br><span class="line"><span class="string">    :param kwargs: 请求参数，headers,cookies,params,data,json...</span></span><br><span class="line"><span class="string">    :return: 请求结果</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 统一请求方法格式</span></span><br><span class="line">    method = method.lower()</span><br><span class="line">    res = getattr(requests, method)(url, **kwargs)</span><br><span class="line">    <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure><p>知识点：getattr()–获取类方法<br>如上代码，获取requests模块下，method方法，跟上对应的参数<br>当然也可以用最基本的方法使用if的条件语句，判断是何种请求方法走不同分支来处理</p><h3 id="日志处理：日志器的封装-log-handler-py"><a href="#日志处理：日志器的封装-log-handler-py" class="headerlink" title="日志处理：日志器的封装-log_handler.py"></a>日志处理：日志器的封装-log_handler.py</h3><p>引用python自带库logging<br>具体逻辑：创建一个日志器–&gt;设置日志的打印等级–&gt;创建一个日志处理器–&gt;格式化日志–&gt;将格式化后的日志添加到日志器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_logger(name, filename, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, fmt=None, debug=False):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    创建日志器</span></span><br><span class="line"><span class="string">    :param name: 日志名称</span></span><br><span class="line"><span class="string">    :param filename: 日志文件名和路径</span></span><br><span class="line"><span class="string">    :param mode:文件读写类型，默认a-追加</span></span><br><span class="line"><span class="string">    :param encoding-编码类型</span></span><br><span class="line"><span class="string">    :param fmt: 日志格式</span></span><br><span class="line"><span class="string">    :param debug: bool-True：调试模式，False-非调试模式</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建一个日志器</span></span><br><span class="line">    logger = logging.getLogger(name)</span><br><span class="line">    <span class="comment"># 设置日志器打印等级--不可省去</span></span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line">    <span class="keyword">if</span> debug is True:</span><br><span class="line">        file_level = logging.DEBUG</span><br><span class="line">        console_level = logging.DEBUG</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        file_level = logging.INFO</span><br><span class="line">        console_level = logging.INFO</span><br><span class="line">    <span class="keyword">if</span> fmt is None:</span><br><span class="line">        fmt = <span class="string">&quot;%(levelname)s:%(asctime)s-[%(filename)s--&gt;line:%(lineno)d]-%(levelname)s:%(message)s&quot;</span></span><br><span class="line">    <span class="comment"># 创建日志处理器</span></span><br><span class="line">    file_handler = logging.FileHandler(filename=filename, mode=mode, encoding=encoding)</span><br><span class="line">    file_handler.setLevel(file_level)</span><br><span class="line">    console_handler = logging.StreamHandler()</span><br><span class="line">    console_handler.setLevel(console_level)</span><br><span class="line">    <span class="comment"># 日志格式化</span></span><br><span class="line">    formatter = logging.Formatter(fmt=fmt)</span><br><span class="line">    file_handler.setFormatter(formatter)</span><br><span class="line">    console_handler.setFormatter(formatter)</span><br><span class="line">    <span class="comment"># 将格式化后的日志处理器添加到日志器上</span></span><br><span class="line">    logger.addHandler(file_handler)</span><br><span class="line">    logger.addHandler(console_handler)</span><br><span class="line">    <span class="built_in">return</span> logger</span><br></pre></td></tr></table></figure><p>日志的处理登记做成了两类，最详细的console类–debug；相对清晰的文件类–info<br>补充：logging模块中的日志等级<br><img src="loglevel.jpg" alt="logging模块日志等级"></p><h3 id="Excel文件处理器–excel-handler-py"><a href="#Excel文件处理器–excel-handler-py" class="headerlink" title="Excel文件处理器–excel_handler.py"></a>Excel文件处理器–excel_handler.py</h3><p>引用三方库：openpyxl<br>下载指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from openpyxl import load_workbook</span><br><span class="line">from pprint import pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_exceldata(path, sheetname):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    从excel读取数据</span></span><br><span class="line"><span class="string">    :param path: excel文件路径</span></span><br><span class="line"><span class="string">    :param sheetname: 表名</span></span><br><span class="line"><span class="string">    :return: 从excel中读取的用例</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># read_only-只读，要读取一个excel文件但是又不想改动他.或者表中的数据量很大，需要分段获取，但是使用read_only需要close()</span></span><br><span class="line">    wb = load_workbook(filename=path, read_only=True)</span><br><span class="line">    sh = wb[sheetname]</span><br><span class="line">    row = sh.max_row</span><br><span class="line">    column = sh.max_column</span><br><span class="line">    <span class="comment"># 获取所有key</span></span><br><span class="line">    keys = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, column+1):</span><br><span class="line">        key = sh.cell(1, i).value</span><br><span class="line">        keys.append(key)</span><br><span class="line">    <span class="comment"># 获取用例参数</span></span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(2, row+1):</span><br><span class="line">        temp =&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, column+1):</span><br><span class="line">            value = sh.cell(i, j).value</span><br><span class="line">            temp[keys[j-1]] = value</span><br><span class="line">        <span class="comment"># # 将请求体&amp;预期数据转换成python对象</span></span><br><span class="line">        <span class="comment"># try:</span></span><br><span class="line">        <span class="comment">#     temp[&#x27;request_data&#x27;] = json.loads(temp[&#x27;request_data&#x27;])</span></span><br><span class="line">        <span class="comment">#     temp[&#x27;expect_data&#x27;] = json.loads(temp[&#x27;expect_data&#x27;])</span></span><br><span class="line">        <span class="comment"># except json.decoder.JSONDecodeError:</span></span><br><span class="line">        <span class="comment">#     raise ValueError(&#x27;用例格式错误！&#x27;)</span></span><br><span class="line">        data.append(temp)</span><br><span class="line">    <span class="built_in">return</span> data</span><br></pre></td></tr></table></figure><p>在整个自动化运行的过程中，几乎不会对excel文件本身数据做修改，因此此处仅用到获取数据的方法load_workbook；定义一个读取数据的方法即可<br>Attention：excel文件模版一定要保持干净！！不要存在非必要的空格行or列，上述方法通过获取最大行和最大列来获取目标数据的<br>我使用的excel的格式：<br><img src="case_demo.jpg" alt="excel_form"><br>则对应上述代码：sheetname=demo<br>在指定范围的for循环中遵循左开右闭。也就是右边的数实际取值是n-1，所以此处column&amp;row都+1<br>最终以列表中嵌套字典的方式，获取所有表中的数据，例：<br>[{“id”:1,””title”:用例A”…,},{…}]</p><h3 id="测试报告生成-report-handler-py"><a href="#测试报告生成-report-handler-py" class="headerlink" title="测试报告生成-report_handler.py"></a>测试报告生成-report_handler.py</h3><p>用例批量执行后需要一个测试报告直观的查看当前测试套执行结果,现在有很多3方测试模板，比如可以直接下载的BeautifulReport</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">from BeautifulReport import BeautifulReport</span><br><span class="line">from library.HTMLTestRunnerNew import HTMLTestRunner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def report(ts, filename, report_dir, theme=<span class="string">&quot;theme_default&quot;</span>, title=None, description=None, tester=None, _type=<span class="string">&#x27;br&#x27;</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    执行用例并生成用例</span></span><br><span class="line"><span class="string">    :param ts: 测试套件</span></span><br><span class="line"><span class="string">    :param filename: 报告文件名</span></span><br><span class="line"><span class="string">    :param report_dir: 报告文件夹 仅支持BeautifulReport</span></span><br><span class="line"><span class="string">    :param theme: 主题，仅支持BeautfulReport</span></span><br><span class="line"><span class="string">    :param title: 报告主题，仅支持HTMLtesterRunner</span></span><br><span class="line"><span class="string">    :param description: 报告描述</span></span><br><span class="line"><span class="string">    :param tester: 测试人员，仅支持HTMLtesterRunner</span></span><br><span class="line"><span class="string">    :param _type: 默认值为bs，表示生产厂BeautifulReport风格的报告</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 生成时间前缀</span></span><br><span class="line">    time_prefix = datetime.now().strftime(<span class="string">&quot;%Y%m%d%H%M%S&quot;</span>)</span><br><span class="line">    <span class="comment"># 拼接到报告文件名</span></span><br><span class="line">    filename = <span class="string">&quot;&#123;&#125;_&#123;&#125;&quot;</span>.format(time_prefix, filename)</span><br><span class="line">    <span class="keyword">if</span> _type == <span class="string">&quot;br&quot;</span>:</span><br><span class="line">        <span class="comment"># 生成BeautifulReport的报告</span></span><br><span class="line">        br = BeautifulReport(ts)</span><br><span class="line">        br.report(description=description, filename=filename, report_dir= report_dir, theme=theme)</span><br><span class="line">        pass</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 生成HTMLtestRunner的报告</span></span><br><span class="line">        with open(report_dir+filename, <span class="string">&quot;wb&quot;</span>) as f:</span><br><span class="line">            runner = HTMLTestRunner(f, title=title, description=description, tester=tester)</span><br><span class="line">            runner.run(ts)</span><br></pre></td></tr></table></figure><h3 id="配置项封装-config-handler-py-settings-py"><a href="#配置项封装-config-handler-py-settings-py" class="headerlink" title="配置项封装-config_handler.py/settings.py"></a>配置项封装-config_handler.py/settings.py</h3><p>为了减少不同环境对框架复用性的影响，封装一个动态配置处理器，常见的配置项管理文件类型有：.ini, .yaml, .yml, .cfg, .conf;但为了更加方便的调用和获取数据，我直接使用python文件进行了配置管理；针对ini&amp;yaml类型的数据不做过多的赘述：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import yaml</span><br><span class="line">from configparser import ConfigParser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_config(filename, encoding=<span class="string">&quot;utf-8&quot;</span>) -&gt; dict:</span><br><span class="line">    <span class="comment"># 获取文件后缀名</span></span><br><span class="line">    suffix = filename.split(<span class="string">&quot;.&quot;</span>)[-1]</span><br><span class="line">    <span class="comment"># 判断配置文件类型</span></span><br><span class="line">    <span class="keyword">if</span> suffix <span class="keyword">in</span> [<span class="string">&quot;ini&quot;</span>, <span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;cnf&quot;</span>]:</span><br><span class="line">        conf = ConfigParser()</span><br><span class="line">        conf.read(filenames=filename, encoding=encoding)</span><br><span class="line">        <span class="comment"># 获取文件中所有key</span></span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> section <span class="keyword">in</span> conf.sections():</span><br><span class="line">            <span class="comment"># 获取对应section下所有value</span></span><br><span class="line">            values = conf.items(section)</span><br><span class="line">            data[section] = dict(values)</span><br><span class="line">    <span class="keyword">elif</span> suffix <span class="keyword">in</span> [<span class="string">&quot;yaml&quot;</span>, <span class="string">&quot;yml&quot;</span>]:</span><br><span class="line">        with open(file=filename, mode=<span class="string">&#x27;r&#x27;</span>, encoding=encoding) as fb:</span><br><span class="line">            data = yaml.load(stream=fb, Loader=yaml.FullLoader)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        raise ValueError(<span class="string">&quot;不能识别的配置文件后缀&quot;</span>)</span><br><span class="line">    <span class="built_in">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Config:</span><br><span class="line">    def __init__(self, filename, encoding=<span class="string">&quot;utf-8&quot;</span>):</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.encoding = encoding</span><br><span class="line">        self.suffix = filename.split(<span class="string">&quot;.&quot;</span>)[-1]</span><br><span class="line">        <span class="keyword">if</span> self.suffix not <span class="keyword">in</span> [<span class="string">&quot;ini&quot;</span>, <span class="string">&quot;conf&quot;</span>, <span class="string">&quot;cnf&quot;</span>, <span class="string">&quot;yml&quot;</span>, <span class="string">&quot;yaml&quot;</span>]:</span><br><span class="line">            raise ValueError(<span class="string">&quot;不能识别的配置文件后缀&quot;</span>)</span><br><span class="line"></span><br><span class="line">    def __parse_ini(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        解析ini文件</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        conf = ConfigParser()</span><br><span class="line">        conf.read(filenames=self.filename, encoding=self.encoding)</span><br><span class="line">        <span class="comment"># 获取文件中所有key</span></span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> section <span class="keyword">in</span> conf.sections():</span><br><span class="line">            <span class="comment"># 获取对应section下所有value</span></span><br><span class="line">            values = conf.items(section)</span><br><span class="line">            data[section] = dict(values)</span><br><span class="line">        <span class="built_in">return</span> data</span><br><span class="line"></span><br><span class="line">    def __parse_yaml(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        解析yaml文件</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        with open(file=self.filename, mode=<span class="string">&#x27;r&#x27;</span>, encoding=self.encoding) as fb:</span><br><span class="line">            data = yaml.load(stream=fb, Loader=yaml.FullLoader)</span><br><span class="line">        <span class="built_in">return</span> data</span><br><span class="line"></span><br><span class="line">    def parse(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        解析</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.suffix <span class="keyword">in</span> [<span class="string">&quot;yaml&quot;</span>, <span class="string">&quot;yml&quot;</span>]:</span><br><span class="line">            <span class="built_in">return</span> self.__parse_yaml()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> self.__parse_ini()</span><br></pre></td></tr></table></figure><p>.ini文件格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">log</span>]</span><br><span class="line">name = <span class="string">&quot;rest_register&quot;</span></span><br><span class="line"></span><br><span class="line">[test_data]</span><br><span class="line"></span><br><span class="line">[report]</span><br></pre></td></tr></table></figure><p>.yaml文件格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>:</span><br><span class="line">  name: dpword_test_log</span><br><span class="line">  filename: <span class="built_in">log</span>/testlog.log</span><br><span class="line">  debug: <span class="literal">true</span></span><br><span class="line">testdata:</span><br><span class="line">  file: data/apicase_lemonregister.xlsx</span><br><span class="line">report:</span><br><span class="line">  filename: testReport/注册接口测试报告.html</span><br><span class="line">  description: 注册模块测试</span><br></pre></td></tr></table></figure><p>settings.py</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">import os</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cur_time = datetime.now().strftime(<span class="string">&quot;%Y%m%d%H%M&quot;</span>)</span><br><span class="line"><span class="comment"># os.path.abspath()--&gt;根据当前操作系统获取对应类型的绝对路径</span></span><br><span class="line">path = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志配置</span></span><br><span class="line">LOG_CONFIG = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;通用日志器&quot;</span>,</span><br><span class="line">    <span class="string">&quot;filename&quot;</span>: os.path.join(path, f<span class="string">&quot;log/&#123;cur_time&#125;testlog.log&quot;</span>),</span><br><span class="line">    <span class="string">&quot;debug&quot;</span>: True</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例配置</span></span><br><span class="line">TEST_DATA = &#123;</span><br><span class="line">    <span class="string">&quot;path&quot;</span>: os.path.join(path, <span class="string">&quot;data/apicase_lemonregister.xlsx&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试报告配置</span></span><br><span class="line">REPORT_CONFIG = &#123;</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;注册接口测试&quot;</span>,</span><br><span class="line">    <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;注册接口测试报告.html&quot;</span>,</span><br><span class="line">    <span class="string">&quot;report_dir&quot;</span>: os.path.join(path, <span class="string">&quot;testReport&quot;</span>),</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;测试报告&quot;</span>,</span><br><span class="line">    <span class="string">&quot;theme&quot;</span>: <span class="string">&quot;theme_cyan&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;br&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 域名</span></span><br><span class="line">DOMAIN = &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;http://api.lemonban.com/futureloan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接口配置</span></span><br><span class="line">INTERFACE = &#123;</span><br><span class="line">    <span class="string">&quot;register&quot;</span>: <span class="string">&quot;/member/register&quot;</span>,</span><br><span class="line">    <span class="string">&quot;login&quot;</span>: <span class="string">&quot;/member/login&quot;</span>,</span><br><span class="line">    <span class="string">&quot;recharge&quot;</span>: <span class="string">&quot;/member/recharge&quot;</span>,</span><br><span class="line">    <span class="string">&quot;add&quot;</span>: <span class="string">&quot;/loan/add&quot;</span>,</span><br><span class="line">    <span class="string">&quot;audit&quot;</span>: <span class="string">&quot;/loan/audit&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库配置</span></span><br><span class="line">DB_CONFIG = &#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;sh-cynosdbmysql-grp-p8d7farc.sql.tencentcdb.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: 29391,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;Deepword2021&quot;</span>,</span><br><span class="line">    <span class="string">&quot;charset&quot;</span>: <span class="string">&quot;utf8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;db&quot;</span>: <span class="string">&quot;deepuser&quot;</span>,</span><br><span class="line">    <span class="string">&quot;autocommit&quot;</span>: True  <span class="comment"># 自动提交事务打开，防止mysql可重复读特性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DB_CONFIG_LEMON = &#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;api.lemonban.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: 3306,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;future&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="string">&quot;charset&quot;</span>: <span class="string">&quot;utf8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;db&quot;</span>: <span class="string">&quot;future&quot;</span>,</span><br><span class="line">    <span class="string">&quot;autocommit&quot;</span>: True,</span><br><span class="line">    <span class="string">&quot;cursorclass&quot;</span>: pymysql.cursors.DictCursor  <span class="comment"># 设置游标类型，返回不同类型数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用python文件管理动态参数的好处就是在执行过程中，python无需再去翻译成自己理解的逻辑再去执行，可以通过字典将不同类型的参数归类，省去了翻译这一步骤。也不容易出现奇怪的非必要的问题。<br>Attention：settings中的参数key均采用大写字母</p><h3 id="数据库处理器-db-handler-py"><a href="#数据库处理器-db-handler-py" class="headerlink" title="数据库处理器-db_handler.py"></a>数据库处理器-db_handler.py</h3><p>当前数据库的类型非常多，诸如关系型—mysql，非关系型—mongodb，redis等等，此处介绍的是最最最基础也最最最常用的mysql的处理<br>引用三方库：pymysql<br>本地没有直接pip：pip install pymysql<br>简单介绍下pymysql的使用：<br>1）    创建数据库连接<br>2）    创建游标对象cursor<br>3）    执行sql语句<br>4）    获取结果<br>5）    关闭数据库连接<br>具体到代码步骤：<br><img src="db_handler.jpg" alt="way_of_pymysql"></p><p>如果仅仅通过定义函数的方法，每一次请求mysql都需要如此来一套，创建连接-执行语句-再关闭连接，一旦数据量大起来对mysql的压力会十分大，且浪费时间和资源；为了解决这个问题，通过封装一个数据库处理类，定义一个初始化函数，创建一个连接，可被其他方法共享连接，详细如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">import settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DB:</span><br><span class="line">    def __init__(self, db_config: dict):</span><br><span class="line">        <span class="comment"># 创建&amp;关闭连接是耗时且浪费资源的，封装成类-仅创建一个连接即可调用多个方法，是比较效率的</span></span><br><span class="line">        self.conn = pymysql.connect(**db_config)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        类运行完毕，关闭数据库链接</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    def get_one_data(self, sql):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        获取查询结果首个数据</span></span><br><span class="line"><span class="string">        :param sql: 执行的sql语句</span></span><br><span class="line"><span class="string">        :return: 查询结果</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        with self.conn.cursor() as cursor:</span><br><span class="line">            cursor.execute(sql)</span><br><span class="line">            <span class="built_in">return</span> cursor.fetchone()</span><br><span class="line"></span><br><span class="line">    def get_many_data(self, sql, num: int):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        获取多个查询结果，指定结果数量</span></span><br><span class="line"><span class="string">        :param sql: 执行的sql语句</span></span><br><span class="line"><span class="string">        :param num: 指定需要抓取的数据数量-int</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        with self.conn.cursor() as cursor:</span><br><span class="line">            cursor.execute(sql)</span><br><span class="line">            <span class="built_in">return</span> cursor.fetchmany(num)</span><br><span class="line"></span><br><span class="line">    def get_all_data(self, sql):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        获取所有查询结果</span></span><br><span class="line"><span class="string">        :param sql: 执行的sql语句</span></span><br><span class="line"><span class="string">        :return: 指定需要抓去的数据数量</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        with self.conn.cursor() as cursor:</span><br><span class="line">            cursor.execute(sql)</span><br><span class="line">            <span class="built_in">return</span> cursor.fetchall()</span><br><span class="line"></span><br><span class="line">    def exist(self, sql):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        查询数据是否存在</span></span><br><span class="line"><span class="string">        :param sql: 执行的sql语句</span></span><br><span class="line"><span class="string">        :return: True-数据存在，False-数据不存在</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        with self.conn.cursor() as cursor:</span><br><span class="line">            cursor.execute(sql)</span><br><span class="line">            <span class="keyword">if</span> cursor.fetchone():</span><br><span class="line">                <span class="built_in">return</span> True</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">return</span> False</span><br></pre></td></tr></table></figure><h3 id="模块初始化-init-py"><a href="#模块初始化-init-py" class="headerlink" title="模块初始化-init.py"></a>模块初始化-<strong>init</strong>.py</h3><p>在整个框架的使用中，有些类和方法被频繁的调用，如果每个模块都要重新引用一次，随着模块的增多，代码免不了冗余和繁琐，对被测系统的性能也会带来非必要的压力，例如频繁的调用数据库处理器，即使封装数据库处理模块的时候已经简化了连接数，但是还不够。<br><strong>init</strong>.py</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from .log_handler import get_logger</span><br><span class="line">import settings</span><br><span class="line"><span class="comment"># from .config_handler import get_config</span></span><br><span class="line">from .db_handler import DB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># config = get_config(&quot;config.yaml&quot;)</span></span><br><span class="line">logger = get_logger(**settings.LOG_CONFIG)</span><br><span class="line"><span class="comment"># 实现单项目共享一个连接，提高资源利用率</span></span><br><span class="line">db_client = DB(settings.DB_CONFIG_LEMON)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p>在自动化测试的过程中，随机参数是必不可少的，可以根据一定的规则生成需要的随机数。为此我单独创建了一个模块random_sample.py来统一生成各种随机数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import string</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_randomsample(length=64, mode=<span class="string">&#x27;mix&#x27;</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    获取指定长度，指定类型随机数，可指定参数类型</span></span><br><span class="line"><span class="string">    :param length:</span></span><br><span class="line"><span class="string">    :param mode:预获取的参数类型，默认mix-大小写英文字母+数字，支持digit：纯数字字符串；letter-纯英文字母</span></span><br><span class="line"><span class="string">    :return:random_result-自定义随机数</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    str_digit = [random.choice(string.digits) <span class="keyword">for</span> i <span class="keyword">in</span> range(length)]</span><br><span class="line">    str_mix = [random.choice(string.ascii_letters + string.digits) <span class="keyword">for</span> i <span class="keyword">in</span> range(length)]</span><br><span class="line">    str_letter = [random.choice(string.ascii_letters) <span class="keyword">for</span> i <span class="keyword">in</span> range(length)]</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;mix&#x27;</span>:</span><br><span class="line">        random_result = <span class="string">&#x27;&#x27;</span>.join(str_mix)</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;digit&#x27;</span>:</span><br><span class="line">        random_result = <span class="string">&#x27;&#x27;</span>.join(str_digit)</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;letter&#x27;</span>:</span><br><span class="line">        random_result = <span class="string">&#x27;&#x27;</span>.join(str_letter)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        random_result = <span class="string">&#x27;Illegal mode&#x27;</span></span><br><span class="line">    <span class="built_in">return</span> random_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_note(<span class="built_in">times</span>=50, sleep=5):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    随机获取音符</span></span><br><span class="line"><span class="string">    :param times:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    musical_note = [<span class="string">&#x27;do&#x27;</span>, <span class="string">&#x27;ra&#x27;</span>, <span class="string">&#x27;mi&#x27;</span>, <span class="string">&#x27;fa&#x27;</span>, <span class="string">&#x27;so&#x27;</span>, <span class="string">&#x27;la&#x27;</span>, <span class="string">&#x27;si&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">times</span>):</span><br><span class="line">        random_note = random.choice(musical_note)</span><br><span class="line">        <span class="built_in">print</span>(random_note)</span><br><span class="line">        time.sleep(sleep)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试数据处理"><a href="#测试数据处理" class="headerlink" title="测试数据处理"></a>测试数据处理</h3><p>随机参数已经有单独的模块生成，那么下一步就是用生成的参数动态替换掉每次从excel中获取的参数槽位，因此又增加了一个处理此问题的模块test_data_handler.py</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">from common import db_client</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_phone():</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    生成随机电话号码，要求：1开头，第二位3-9的数字，总共11位</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    sec_num = str(random.randint(3, 9))</span><br><span class="line">    tail_num = [<span class="string">&quot;1&quot;</span>, sec_num]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(8):</span><br><span class="line">        ele = str(random.randint(0, 9))</span><br><span class="line">        tail_num.append(ele)</span><br><span class="line">    phone = <span class="string">&#x27;&#x27;</span>.join(tail_num)</span><br><span class="line">    <span class="built_in">return</span> phone</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_phone2():</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    生成随机电话号码</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    sample = [<span class="string">&quot;135&quot;</span>, <span class="string">&quot;136&quot;</span>, <span class="string">&quot;137&quot;</span>, <span class="string">&quot;138&quot;</span>, <span class="string">&quot;139&quot;</span>, <span class="string">&quot;158&quot;</span>, <span class="string">&quot;159&quot;</span>, <span class="string">&quot;188&quot;</span>,</span><br><span class="line">              <span class="string">&quot;132&quot;</span>, <span class="string">&quot;156&quot;</span>, <span class="string">&quot;133&quot;</span>, <span class="string">&quot;153&quot;</span>, <span class="string">&quot;180&quot;</span>, <span class="string">&quot;189&quot;</span>]</span><br><span class="line">    header = random.choice(sample)</span><br><span class="line">    phone_sample = [header]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(8):</span><br><span class="line">        ele = str(random.randint(0, 9))</span><br><span class="line">        phone_sample.append(ele)</span><br><span class="line">    phone = <span class="string">&#x27;&#x27;</span>.join(phone_sample)</span><br><span class="line">    <span class="built_in">return</span> phone</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_no_user_phone(sql=<span class="string">&quot;select * from member where mobile_phone = &#123;&#125;&quot;</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    生成库内不存在的随机电话号码，要求：1开头，第二位3-9的数字，总共11位</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 生成随机手机号</span></span><br><span class="line">    phone = generate_phone2()</span><br><span class="line">    sql = sql.format(phone)</span><br><span class="line">    phone_tuple = db_client.exist(sql)</span><br><span class="line">    <span class="keyword">while</span> phone_tuple:</span><br><span class="line">        phone = generate_phone2()</span><br><span class="line">    <span class="built_in">return</span> phone</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def replace_by_re(json_str, object):</span><br><span class="line">    args = re.findall(<span class="string">&quot;#(.+?)#&quot;</span>, json_str)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        json_str = json_str.replace(<span class="string">&quot;#&#123;&#125;#&quot;</span>.format(arg), str(getattr(object, arg)))</span><br><span class="line">    <span class="built_in">return</span> json_str</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个模块除了替换槽位的方法是通用的，其他方法均需要根据实际的业务场景来定义不同的方法。那么这里讲解一下replace_by_re()这个方法。<br>这里重点引用的方法re – 正则匹配<br>此处不会详细介绍正则表达式。仅对用到的正则匹配方法做介绍。<br>re.findall<br>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。<br>注意： match 和 search 是匹配一次 findall 匹配所有。<br>语法格式为：<br>findall(string[, pos[, endpos]])<br>参数：<br>•    string : 待匹配的字符串。<br>•    pos : 可选参数，指定字符串的起始位置，默认为 0。<br>•    endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(r<span class="string">&#x27;\d+&#x27;</span>)   <span class="comment"># 查找数字</span></span><br><span class="line">result1 = pattern.findall(<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line">result2 = pattern.findall(<span class="string">&#x27;run88oob123google456&#x27;</span>, 0, 18)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result1)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;12&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此处用到的正则表达式模式：</p><ol><li>   利用括号分组</li><li>   用问号实现可选匹配</li><li>   用星号匹配零次或多次</li><li>   用加号匹配一次或多次</li><li>   通配字符</li></ol><p>在正则表达式中，.(英文句号)为通配符，它匹配除了换行之外的所有字符串<br>Attention：. 仅匹配一个字符<br>eg.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atRegex = re.compile(r’.at’)</span><br><span class="line">atRegex.findall(“The cat <span class="keyword">in</span> the hat sat on the flat mat.”)</span><br></pre></td></tr></table></figure><p>Result: [“cat”, “hat”, “sat”, “lat”, “mat”]<br>结果中flat仅匹配到了lat</p><p>（）为分组符号<br>一个括号内的字符为一组，可以使用group()匹配对象方法，从一个分组中获取匹配的文本。<br>Eg.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">phoneNumRegex = re.compile(r“(\d\d\d)-(\d\d\d-\d\d\d)”)</span><br><span class="line">mo = phoneNumRegex.search(“My number is 415-555-4242.”)</span><br><span class="line">mo.group(1)</span><br><span class="line"><span class="comment"># 415</span></span><br><span class="line">mo.group(2)</span><br><span class="line"><span class="comment"># 555-4242</span></span><br><span class="line">mo.group(0)</span><br><span class="line"><span class="comment"># 415-555-4242</span></span><br><span class="line">mo.group()</span><br><span class="line"><span class="comment"># 415-555-4242</span></span><br></pre></td></tr></table></figure><p>？表明它前面的分组在这个模式中是可选的，可以理解为：匹配这个问号之前的分组0次后者1次<br>*意味着匹配0次或多次，即星号之前的分组，可以在文本中出现任意次，它可以不存在，或者一次又一次的重复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">batRegex = re.compile(r”Bat(wo)*man”)</span><br><span class="line">mo1 = batRegex.search(“The Adventures of Batman”)</span><br><span class="line">mo1.group()</span><br><span class="line"><span class="comment"># result: “Batman”</span></span><br><span class="line">mo2 = batRegex.search(“The Adventures of Batwoman”)</span><br><span class="line">mo2.group()</span><br><span class="line"><span class="comment"># result: “Batwoman”</span></span><br><span class="line">mo3 = batRegex.search(“The Adventures of Batwowowowoman”)</span><br><span class="line">mo3 = mo3.group()</span><br><span class="line"><span class="comment"># result: “Batwowowowoman”</span></span><br></pre></td></tr></table></figure><p>+意味着匹配一次或多次，相比较星号不要求分组出现在匹配的字符串中，加号前的分组必须至少出现一次。<br>多个匹配模式，返回元祖列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">result = re.findall(r<span class="string">&#x27;(\w+)=(\d+)&#x27;</span>, <span class="string">&#x27;set width=20 and height=10&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：<br>[(‘width’, ‘20’),(‘height’, ‘10’)]<br>综合以上知识点，来看框架代码中的“#(.+?)#”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def replace_by_re(json_str, object):</span><br><span class="line">   args = re.findall(<span class="string">&quot;#(.+?)#&quot;</span>, json_str)</span><br><span class="line">   <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">       json_str = json_str.replace(<span class="string">&quot;#&#123;&#125;#&quot;</span>.format(arg), str(getattr(object, arg)))</span><br><span class="line">   <span class="built_in">return</span> json_str</span><br></pre></td></tr></table></figure><p>被匹配的字符串为json_str<br>在json_str中匹配的字符串格式为#xxx#，考虑到json_str中可能存在多个这样格式的字符串，所以用井号将字符分组，分组内的字符串无特殊的要求所以使用通配符匹配分组内的所有字符串。但是有一个要求，井号内字符不能为空，所以使用+号保证预匹配的字符串必须完整的存在一次</p><h3 id="前置用例"><a href="#前置用例" class="headerlink" title="前置用例"></a>前置用例</h3><p>业务流<br>在做接口自动化时，往往需要先测通核心业务流，再进行单接口测试<br>接口测试业务流设计<br>1）站在用户角度<br>2）重视全局而非细节<br>3）先测主流程，后测分流程<br>4）只测正例</p><h3 id="基于Unittest框架的测试执行模块的封装"><a href="#基于Unittest框架的测试执行模块的封装" class="headerlink" title="基于Unittest框架的测试执行模块的封装"></a>基于Unittest框架的测试执行模块的封装</h3><p>涉及三方库：ddt<br>—-data driver test—数据驱动测试，只有测试流程完全一致的时候可以使用ddt<br>目的：测试数据与测试用例代码分离，通过外部测试数据动态生成用例<br>下载执行：pip install ddt<br>下载好后为了更好的适配本地的脚本，修改了一小部分代码(进入ddt模块找这段):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def _get_test_data_docstring(func, value):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Returns a docstring based on the following resolution strategy:</span></span><br><span class="line"><span class="string">    1. Passed value is not a &quot;</span>primitive<span class="string">&quot; and has a docstring, then use it.</span></span><br><span class="line"><span class="string">    2. In all other cases return None, i.e the test name is used.</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> value.get(<span class="string">&#x27;title&#x27;</span>, None):</span><br><span class="line">        <span class="built_in">return</span> value.get(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> not _is_primitive(value) and value.__doc__:</span><br><span class="line">        <span class="built_in">return</span> value.__doc__</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">return</span> None</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果就是将html报告中的用例描述，取用excel中填入的title的值</p><p>1．    相同业务模块为一个py文件<br><img src="testcases_modle.jpg" alt="testcases_modle"></p><p>2．    为了简化和解耦，减少后续模块代码量，可以编写一个基类如base_case.py，逻辑与common目录下的__init__.py一样；在基类中定义通用的流程和代码逻辑，例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line">import json</span><br><span class="line">import warnings</span><br><span class="line">import settings</span><br><span class="line">from common import logger, db_client</span><br><span class="line">from common.test_data_handler import replace_by_re, generate_no_user_phone</span><br><span class="line">from common.http_request import send_http_requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseTest(unittest.TestCase):</span><br><span class="line">    name = <span class="string">&quot;base用例&quot;</span>  <span class="comment"># 这个属性应该被覆盖</span></span><br><span class="line">    logger = logger</span><br><span class="line">    db = db_client</span><br><span class="line">    settings = settings</span><br><span class="line">    @classmethod</span><br><span class="line">    def setUpClass(cls) -&gt; None:</span><br><span class="line">        warnings.simplefilter(<span class="string">&#x27;ignore&#x27;</span>, ResourceWarning)</span><br><span class="line">        cls.logger.info(<span class="string">&quot;=====================&#123;&#125;接口开始测试========================&quot;</span>.format(cls.name))</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def tearDownClass(cls) -&gt; None:</span><br><span class="line">        cls.logger.info(<span class="string">&quot;=====================&#123;&#125;接口测试结束========================&quot;</span>.format(cls.name))</span><br><span class="line"></span><br><span class="line">    def setUp(self) -&gt; None:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        方法级的前置条件，每个测试函数执行前执行</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        self.logger.info(<span class="string">&quot;用例测试开始！&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    def tearDown(self) -&gt; None:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        方法级后置处理，每个测试函数执行结束执行</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        self.logger.info(<span class="string">&quot;用例测试结束！&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    def checkout(self, <span class="keyword">case</span>):</span><br><span class="line">        <span class="comment"># 测试数据处理-绑定对象属性，便于下面的测试流程处理函数</span></span><br><span class="line">        self.case = <span class="keyword">case</span></span><br><span class="line">        self.case[<span class="string">&quot;url&quot;</span>] = settings.DOMAIN[<span class="string">&quot;test&quot;</span>] + settings.INTERFACE[<span class="keyword">case</span>[<span class="string">&quot;url&quot;</span>]]</span><br><span class="line">        <span class="comment"># 测试数据处理</span></span><br><span class="line">        self.pre_test_data()</span><br><span class="line">        <span class="comment"># 测试步骤</span></span><br><span class="line">        self.step()</span><br><span class="line">        <span class="comment"># 响应状态码断言</span></span><br><span class="line">        self.assert_status_code()</span><br><span class="line">        <span class="comment"># 响应数据断言</span></span><br><span class="line">        self.assert_json_response()</span><br><span class="line">        <span class="comment"># 数据库断言</span></span><br><span class="line">        self.assert_db_true()</span><br><span class="line"></span><br><span class="line">    def pre_test_data(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        预制数据处理</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 判断是否生成手机号码</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;#phone#&quot;</span> <span class="keyword">in</span> self.case[<span class="string">&quot;request_data&quot;</span>]:</span><br><span class="line">            phone = generate_no_user_phone()</span><br><span class="line">            <span class="comment"># 替换槽位</span></span><br><span class="line">            self.case[<span class="string">&quot;request_data&quot;</span>] = self.case[<span class="string">&quot;request_data&quot;</span>].replace(<span class="string">&quot;#phone#&quot;</span>, phone)</span><br><span class="line">            <span class="keyword">if</span> self.case.get(<span class="string">&quot;sql&quot;</span>):</span><br><span class="line">                self.case[<span class="string">&quot;sql&quot;</span>] = self.case[<span class="string">&quot;sql&quot;</span>].replace(<span class="string">&quot;#phone#&quot;</span>, phone)</span><br><span class="line">        <span class="comment"># 替换槽位</span></span><br><span class="line">        self.case[<span class="string">&quot;request_data&quot;</span>] = replace_by_re(self.case[<span class="string">&quot;request_data&quot;</span>], self)</span><br><span class="line">        <span class="keyword">if</span> self.case.get(<span class="string">&quot;sql&quot;</span>):  <span class="comment"># 针对部分用例不涉及sql校验，使用此方法保证不会因为sql为空时报错</span></span><br><span class="line">            try:</span><br><span class="line">                self.case[<span class="string">&quot;sql&quot;</span>] = replace_by_re(self.case[<span class="string">&quot;sql&quot;</span>], self)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                self.logger.error(<span class="string">&quot;用例用例：&#123;&#125;替换sql槽位失败！&quot;</span>.format(self.case[<span class="string">&quot;sql&quot;</span>]))</span><br><span class="line">                raise e</span><br><span class="line">        <span class="comment"># 将数据转换位python对象</span></span><br><span class="line">        try:</span><br><span class="line">            self.case[<span class="string">&quot;request_data&quot;</span>] = json.loads(self.case[<span class="string">&quot;request_data&quot;</span>])</span><br><span class="line">            self.case[<span class="string">&quot;expect_data&quot;</span>] = json.loads(self.case[<span class="string">&quot;expect_data&quot;</span>])</span><br><span class="line">        except Exception as e:</span><br><span class="line">            self.logger.error(<span class="string">&quot;用例：&#123;&#125;数据转换字符串失败！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">            raise e</span><br><span class="line"></span><br><span class="line">    def step(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        测试步骤</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        try:</span><br><span class="line">            self.response = send_http_requests(url=self.case[<span class="string">&quot;url&quot;</span>], method=self.case[<span class="string">&quot;method&quot;</span>],</span><br><span class="line">                                               **self.case[<span class="string">&quot;request_data&quot;</span>])</span><br><span class="line">        except Exception as e:</span><br><span class="line">            self.logger.exception(<span class="string">&quot;用例：【&#123;&#125;】发送http请求失败&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">            self.logger.debug(<span class="string">&quot;method:&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;method&quot;</span>]))</span><br><span class="line">            self.logger.debug(<span class="string">&quot;response_data:&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;request_data&quot;</span>]))</span><br><span class="line">            self.logger.info(<span class="string">&quot;响应结果：&#123;&#125;&quot;</span>.format(self.response.json()))</span><br><span class="line">            self.logger.info(<span class="string">&quot;预期结果：&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;expect_data&quot;</span>]))</span><br><span class="line">            raise e</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.logger.info(<span class="string">&quot;用例【&#123;&#125;】发送http请求成功！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line"></span><br><span class="line">    def assert_status_code(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        响应状态码断言</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        try:</span><br><span class="line">            self.assertEqual(int(self.case[<span class="string">&quot;status_code&quot;</span>]), self.response.status_code)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            self.logger.exception(<span class="string">&quot;用例：【&#123;&#125;】响应状态码断言失败！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">            raise e</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.logger.info(<span class="string">&quot;响应状态码断言成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    def assert_json_response(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        json响应结果断言--根据情况这里只校验了部分参数，根据实际项改写</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 这里的逻辑写死，只是针对当前项目</span></span><br><span class="line">        res_data = self.response.json()</span><br><span class="line">        try:</span><br><span class="line">            self.assertEqual(self.case[<span class="string">&#x27;expect_data&#x27;</span>][<span class="string">&#x27;code&#x27;</span>], res_data[<span class="string">&#x27;code&#x27;</span>])</span><br><span class="line">            self.assertEqual(self.case[<span class="string">&#x27;expect_data&#x27;</span>][<span class="string">&#x27;msg&#x27;</span>], res_data[<span class="string">&#x27;msg&#x27;</span>])</span><br><span class="line">        except Exception as e:</span><br><span class="line">            self.logger.exception(<span class="string">&quot;用例：【&#123;&#125;】响应结果断言失败！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">            self.logger.debug(<span class="string">&quot;预期结果：&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;expect_data&quot;</span>][<span class="string">&quot;code&quot;</span>]))</span><br><span class="line">            self.logger.debug(<span class="string">&quot;预期结果：&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;expect_data&quot;</span>][<span class="string">&quot;msg&quot;</span>]))</span><br><span class="line">            self.logger.debug(<span class="string">&quot;实际结果：&#123;&#125;&quot;</span>.format(res_data[<span class="string">&#x27;code&#x27;</span>]))</span><br><span class="line">            self.logger.debug(<span class="string">&quot;实际结果：&#123;&#125;&quot;</span>.format(res_data[<span class="string">&#x27;msg&#x27;</span>]))</span><br><span class="line">            raise e</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.logger.info(<span class="string">&quot;用例：【&#123;&#125;】响应结果断言成功！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line"></span><br><span class="line">    def assert_db_true(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        断言数据库存在数据</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.case.get(<span class="string">&quot;sql&quot;</span>):</span><br><span class="line">            <span class="comment"># 查询数据</span></span><br><span class="line">            try:</span><br><span class="line">                db_res = self.db.exist(self.case[<span class="string">&quot;sql&quot;</span>])</span><br><span class="line">                self.assertTrue(db_res)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                self.logger.exception(<span class="string">&quot;用例：【&#123;&#125;】数据库断言失败！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">                self.logger.debug(<span class="string">&quot;执行sql：&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;sql&quot;</span>]))</span><br><span class="line">                raise e</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.logger.info(<span class="string">&quot;数据库断言成功！&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中，遵循流程：<br>前置&amp;后置用例内容定义：<br>针对类的setUpClass &amp; tearDownClass;<br>针对方法的setup&amp;teardown<br>测试流程的定义：<br>测试步骤-&gt;响应状态码断言-&gt;响应数据断言-&gt;数据库断言</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def checkout(self, <span class="keyword">case</span>):</span><br><span class="line">    <span class="comment"># 测试数据处理-绑定对象属性，便于下面的测试流程处理函数</span></span><br><span class="line">    self.case = <span class="keyword">case</span></span><br><span class="line">    self.case[<span class="string">&quot;url&quot;</span>] = settings.DOMAIN[<span class="string">&quot;test&quot;</span>] + settings.INTERFACE[<span class="keyword">case</span>[<span class="string">&quot;url&quot;</span>]]</span><br><span class="line">    <span class="comment"># 测试数据处理</span></span><br><span class="line">    self.pre_test_data()</span><br><span class="line">    <span class="comment"># 测试步骤</span></span><br><span class="line">    self.step()</span><br><span class="line">    <span class="comment"># 响应状态码断言</span></span><br><span class="line">    self.assert_status_code()</span><br><span class="line">    <span class="comment"># 响应数据断言</span></span><br><span class="line">    self.assert_json_response()</span><br><span class="line">    <span class="comment"># 数据库断言</span></span><br><span class="line">    self.assert_db_true()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此处的checkout方法其实是对上述步骤的一个汇总调用，在TestBase基类中定义每个步骤的处理方法，再定义一个汇总的调用方法，那么后续拥有相同测试步骤的模块用例就可以直接调用checkout(case)，这一种方法来执行整个用例了。<br>以下为每个测试步骤的方法定义：<br>self.pre_test_data()—预制数据处理<br>必然存在的步骤：<br>1）    参数替换；<br>2）    将excel文件中请求体转换成python对象，方便直接引用进接口请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def pre_test_data(self):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    预制数据处理</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 替换槽位</span></span><br><span class="line">    try:</span><br><span class="line">        self.case[<span class="string">&quot;request_data&quot;</span>] = replace_by_re(self.case[<span class="string">&quot;request_data&quot;</span>], self)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        self.logger.error(<span class="string">&quot;用例：&#123;&#125;替换槽位失败&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">        raise e</span><br><span class="line">    <span class="keyword">if</span> self.case.get(<span class="string">&quot;sql&quot;</span>):  <span class="comment"># 针对部分用例不涉及sql校验，使用此方法保证不会因为sql为空时报错</span></span><br><span class="line">        try:</span><br><span class="line">            self.case[<span class="string">&quot;sql&quot;</span>] = replace_by_re(self.case[<span class="string">&quot;sql&quot;</span>], self)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            self.logger.error(<span class="string">&quot;用例用例：&#123;&#125;替换sql槽位失败！&quot;</span>.format(self.case[<span class="string">&quot;sql&quot;</span>]))</span><br><span class="line">            raise e</span><br></pre></td></tr></table></figure><p>self.step() # 测试步骤<br>发送http请求，当然除了http请求之外还有诸如websocket请求，根据具体项目进行封装处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def step(self):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    测试步骤</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    try:</span><br><span class="line">        self.response = send_http_requests(url=self.case[<span class="string">&quot;url&quot;</span>], method=self.case[<span class="string">&quot;method&quot;</span>],</span><br><span class="line">                                           **self.case[<span class="string">&quot;request_data&quot;</span>])</span><br><span class="line">    except Exception as e:</span><br><span class="line">        self.logger.exception(<span class="string">&quot;用例：【&#123;&#125;】发送http请求失败&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">        self.logger.debug(<span class="string">&quot;method:&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;method&quot;</span>]))</span><br><span class="line">        self.logger.debug(<span class="string">&quot;response_data:&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;request_data&quot;</span>]))</span><br><span class="line">        self.logger.info(<span class="string">&quot;响应结果：&#123;&#125;&quot;</span>.format(self.response.json()))</span><br><span class="line">        self.logger.info(<span class="string">&quot;预期结果：&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;expect_data&quot;</span>]))</span><br><span class="line">        raise e</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.logger.info(<span class="string">&quot;用例【&#123;&#125;】发送http请求成功！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br></pre></td></tr></table></figure><p>self.assert_status_code() # 响应状态码断言<br>针对上述http请求结果与excel中提取的预期结果做比较</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def assert_status_code(self):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    响应状态码断言</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    try:</span><br><span class="line">        self.assertEqual(int(self.case[<span class="string">&quot;status_code&quot;</span>]), self.response.status_code)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        self.logger.exception(<span class="string">&quot;用例：【&#123;&#125;】响应状态码断言失败！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">        raise e</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.logger.info(<span class="string">&quot;响应状态码断言成功！&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>self.assert_json_response() —-响应结果断言，这个非固定，切记：所有的框架的代码都是不固定的，一定是根据对应的业务场景做变更的，这里就直接提供一个简单粗暴的方式<br>提取excel中对应的响应体与上述http请求结果做比较</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def assert_json_response(self):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    响应结果断言--根据情况这里只校验了部分参数，根据实际项改写</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 这里的逻辑写死，只是针对当前项目</span></span><br><span class="line">    res_data = self.response.json()</span><br><span class="line">    try:</span><br><span class="line">        self.assertEqual(self.case[<span class="string">&#x27;expect_data&#x27;</span>][<span class="string">&#x27;code&#x27;</span>], res_data[<span class="string">&#x27;code&#x27;</span>])</span><br><span class="line">        self.assertEqual(self.case[<span class="string">&#x27;expect_data&#x27;</span>][<span class="string">&#x27;msg&#x27;</span>], res_data[<span class="string">&#x27;msg&#x27;</span>])</span><br><span class="line">    except Exception as e:</span><br><span class="line">        self.logger.exception(<span class="string">&quot;用例：【&#123;&#125;】响应结果断言失败！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">        self.logger.debug(<span class="string">&quot;预期结果：&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;expect_data&quot;</span>][<span class="string">&quot;code&quot;</span>]))</span><br><span class="line">        self.logger.debug(<span class="string">&quot;预期结果：&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;expect_data&quot;</span>][<span class="string">&quot;msg&quot;</span>]))</span><br><span class="line">        self.logger.debug(<span class="string">&quot;实际结果：&#123;&#125;&quot;</span>.format(res_data[<span class="string">&#x27;code&#x27;</span>]))</span><br><span class="line">        self.logger.debug(<span class="string">&quot;实际结果：&#123;&#125;&quot;</span>.format(res_data[<span class="string">&#x27;msg&#x27;</span>]))</span><br><span class="line">        raise e</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.logger.info(<span class="string">&quot;用例：【&#123;&#125;】响应结果断言成功！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>self.assert_db_true() —-数据库校验，原理同上述响应断言，提取excel文件中的sql语句，连接并执行数据库语句，此处事例为mysql可以根据具体的项目架构需求再封装诸如：redis连接，mogodb连接，甚至是es查询<br>源码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def assert_db_true(self):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    断言数据库存在数据</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.case.get(<span class="string">&quot;sql&quot;</span>):             <span class="comment">#[get]尝试获取对应数据，若没有返回空，而不会报错</span></span><br><span class="line">        <span class="comment"># 查询数据</span></span><br><span class="line">        try:</span><br><span class="line">            db_res = self.db.exist(self.case[<span class="string">&quot;sql&quot;</span>])</span><br><span class="line">            self.assertTrue(db_res)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            self.logger.exception(<span class="string">&quot;用例：【&#123;&#125;】数据库断言失败！&quot;</span>.format(self.case[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">            self.logger.debug(<span class="string">&quot;执行sql：&#123;&#125;&quot;</span>.format(self.case[<span class="string">&quot;sql&quot;</span>]))</span><br><span class="line">            raise e</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.logger.info(<span class="string">&quot;数据库断言成功！&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，整理一下抽取基类的思路：数据参数化，相同步骤统一执行</p><ol><li>   数据参数化：将所有的非定值的数据作为槽位。使用随机数或按照一定规律生成的参数对号入座，槽位表示的方式很多，具体看如何定义，可以是#randint#也可以是{randint}；最后将替换完槽位的数据统一进行格式化，由字符串（str）转换为可被python直接用于请求的python对象。</li><li>   相同的步骤执行：不难发现，所有接口测试都绕不开：填写参数-&gt;发送请求-&gt;获取响应-&gt;状态码&amp;响应体的校验<br>当然有的也存在数据库的校验<br>那么在第一步数据参数化的时候，在针对某一模块也可以简单的理解为对一个sheet页中所有的请求参数都做了统一的替换和格式化<br>那么我只需要在Unittest和ddt的帮助下，一条一条的执行用例即可</li><li>   前置&amp;后置条件：非必要，基本上基类中只需要标注xxx开始执行，xxx执行结束即可，因为接口自动化的最终目的是整个业务场景的验证，所以必然存在不同模块的前置和后置执行内容不一致的情况-需要针对不同的模块做改写。所以基类无需做过多封装<br>类级别—setUpClass &amp; tearDownClass<br>方法级别—setUp &amp; teardown</li></ol><p>测试基类本身就是针对Unittest的属性和方法改写，而项目开发则是具体到每个功能测试模块，再引入基类再改写的过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@data(*cases)</span><br><span class="line">   def test_audit(self, <span class="keyword">case</span>):</span><br><span class="line">       self.logger.info(<span class="string">&quot;用例【&#123;&#125;】开始测试&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>.format(<span class="keyword">case</span>[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">       <span class="comment"># 1. 用例数据处理</span></span><br><span class="line">       <span class="keyword">case</span>[<span class="string">&quot;request_data&quot;</span>] = replace_by_re(<span class="keyword">case</span>[<span class="string">&quot;request_data&quot;</span>], TestAudit)</span><br><span class="line">       <span class="keyword">case</span>[<span class="string">&quot;request_data&quot;</span>] = json.loads(<span class="keyword">case</span>[<span class="string">&quot;request_data&quot;</span>])</span><br><span class="line">       <span class="keyword">case</span>[<span class="string">&quot;expect_data&quot;</span>] = json.loads(<span class="keyword">case</span>[<span class="string">&quot;expect_data&quot;</span>])</span><br><span class="line">       <span class="keyword">case</span>[<span class="string">&quot;url&quot;</span>] = settings.DOMAIN[<span class="string">&quot;test&quot;</span>] + settings.INTERFACE[<span class="keyword">case</span>[<span class="string">&quot;url&quot;</span>]]</span><br><span class="line">       self.logger.debug(<span class="string">&quot;请求URL：&#123;&#125;&quot;</span>.format(<span class="keyword">case</span>[<span class="string">&quot;url&quot;</span>]))</span><br><span class="line">       <span class="comment"># 2. 测试步骤</span></span><br><span class="line">       self.logger.debug(<span class="string">&quot;method:&#123;&#125;&quot;</span>.format(<span class="keyword">case</span>[<span class="string">&quot;method&quot;</span>]))</span><br><span class="line">       self.logger.debug(<span class="string">&quot;args:&#123;&#125;&quot;</span>.format(<span class="keyword">case</span>[<span class="string">&quot;request_data&quot;</span>]))</span><br><span class="line">       response = send_http_requests(url=<span class="keyword">case</span>[<span class="string">&quot;url&quot;</span>], method=<span class="keyword">case</span>[<span class="string">&quot;method&quot;</span>], **<span class="keyword">case</span>[<span class="string">&quot;request_data&quot;</span>])</span><br><span class="line">       self.logger.info(<span class="string">&quot;响应结果：&#123;&#125;&quot;</span>.format(response.json()))</span><br><span class="line">       self.logger.info(<span class="string">&quot;预期结果：&#123;&#125;&quot;</span>.format(<span class="keyword">case</span>[<span class="string">&quot;expect_data&quot;</span>]))</span><br><span class="line">       <span class="comment"># 3. 断言</span></span><br><span class="line">       try:</span><br><span class="line">           self.assertEqual(int(<span class="keyword">case</span>[<span class="string">&quot;status_code&quot;</span>]), response.status_code)</span><br><span class="line">           self.assertEqual(<span class="keyword">case</span>[<span class="string">&#x27;expect_data&#x27;</span>][<span class="string">&#x27;code&#x27;</span>], response.json()[<span class="string">&#x27;code&#x27;</span>])</span><br><span class="line">           self.assertEqual(<span class="keyword">case</span>[<span class="string">&#x27;expect_data&#x27;</span>][<span class="string">&#x27;msg&#x27;</span>], response.json()[<span class="string">&#x27;msg&#x27;</span>])</span><br><span class="line">       except AssertionError as e:</span><br><span class="line">           self.logger.exception(<span class="string">&quot;用例【&#123;&#125;】响应结果断言失败！&quot;</span>.format(<span class="keyword">case</span>[<span class="string">&quot;title&quot;</span>]))</span><br><span class="line">           self.logger.debug(<span class="string">&quot;预期结果:&#123;&#125;&quot;</span>.format(<span class="keyword">case</span>[<span class="string">&quot;expect_data&quot;</span>]))</span><br><span class="line">           self.logger.debug(<span class="string">&quot;响应结果:&#123;&#125;&quot;</span>.format(response.json()))</span><br><span class="line">           raise e</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           self.logger.info(<span class="string">&quot;响应结果断言成功！&quot;</span>)</span><br><span class="line">       <span class="comment"># 数据库校验</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">case</span>[<span class="string">&#x27;sql&#x27;</span>]:</span><br><span class="line">           try:</span><br><span class="line">               <span class="keyword">case</span>[<span class="string">&#x27;sql&#x27;</span>] = replace_by_re(<span class="keyword">case</span>[<span class="string">&#x27;sql&#x27;</span>], TestAudit)</span><br><span class="line">               self.logger.debug(<span class="string">&quot;查询语句为：&#123;&#125;&quot;</span>.format(<span class="keyword">case</span>[<span class="string">&quot;sql&quot;</span>]))</span><br><span class="line">               db_res = self.db.exist(<span class="keyword">case</span>[<span class="string">&#x27;sql&#x27;</span>])</span><br><span class="line">           except Exception as e:</span><br><span class="line">               self.logger.exception(<span class="string">&quot;数据库断言失败！&quot;</span>)</span><br><span class="line">               self.logger.debug(<span class="string">&quot;执行的sql:&#123;&#125;&quot;</span>.format(<span class="keyword">case</span>[<span class="string">&#x27;sql&#x27;</span>]))</span><br><span class="line">               raise e</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               self.logger.info(<span class="string">&quot;数据库断言成功！&quot;</span>)</span><br><span class="line">           self.assertTrue(db_res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码直接可以写为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@data(*cases)</span><br><span class="line">    def test_audit(self, <span class="keyword">case</span>):</span><br><span class="line">        self.checkout(<span class="keyword">case</span>)</span><br></pre></td></tr></table></figure><p>有了基类的帮忙，原本繁琐的步骤，3行代码引用即可解决，工具化</p><p>Attention!!!—-用于占位的槽位名称一定要与预置的参数命名一直，如excel文件中定义的槽位名称为#user_id#，则在预置用例中需要将参数命名为user_id的类属性。</p><p>当存在与通用步骤不一致的业务步骤，只需要继承基类后，直接改写或者重写方法即可。<br>至此，框架的基础搭建就结束了，后续需要根据具体的业务增加相关的处理模块。</p><h3 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h3><p>编写一个执行文件，收集测试套，并让他按照既定的流程执行使用excel归档的用例，将最终的执行结果汇总成html的测试报告</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from common.report_handler import report</span><br><span class="line">import settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    testsuite = unittest.TestLoader().discover(<span class="string">&#x27;testcases&#x27;</span>, pattern=<span class="string">&#x27;test*&#x27;</span>)</span><br><span class="line">    report(testsuite, **settings.REPORT_CONFIG)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于Unittest的接口自动化测试框架，可直接套用，根据实际业务做内容修改&lt;/p&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;catalo</summary>
      
    
    
    
    
    <category term="python 接口自动化" scheme="http://example.com/tags/python-%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>openpyxl实操</title>
    <link href="http://example.com/2022/02/22/openpyxl%E5%AE%9E%E6%93%8D/"/>
    <id>http://example.com/2022/02/22/openpyxl%E5%AE%9E%E6%93%8D/</id>
    <published>2022-02-21T18:40:18.000Z</published>
    <updated>2022-02-23T18:46:24.894Z</updated>
    
    <content type="html"><![CDATA[<p>运用openpyxl模块完成文件内容的批量写入excel操作<br>确保本地存在openpyxl模块<br>若不存在：pip install openpyxl<br>1.新建excel文件，并写入数据，保存至指定位置<br>2.打开已存在的excel文件，追加写入内容</p><h2 id="新建excel文件并写入"><a href="#新建excel文件并写入" class="headerlink" title="新建excel文件并写入"></a>新建excel文件并写入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  @Time : 2/22/22</span></span><br><span class="line"><span class="comment">#  @Author : 柒仔</span></span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line">import openpyxl</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建设备id</span></span><br><span class="line">def device_id():</span><br><span class="line">    chars = string.ascii_letters + string.digits</span><br><span class="line">    deviceid = <span class="string">&#x27;&#x27;</span>.join((random.choice(chars) <span class="keyword">for</span> i <span class="keyword">in</span> range(random.randint(11, 512))))</span><br><span class="line">    <span class="built_in">return</span> deviceid</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机生成设备名称</span></span><br><span class="line">def device_name():</span><br><span class="line">    num = string.ascii_letters + string.digits</span><br><span class="line">    devicename = <span class="string">&#x27;&#x27;</span>.join((random.choice(num) <span class="keyword">for</span> i <span class="keyword">in</span> range(random.randint(1,64))))</span><br><span class="line">    <span class="built_in">return</span> devicename</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建excel文件并写入数据</span></span><br><span class="line">def output_file(filename,sheetname=<span class="string">&#x27;sheet1&#x27;</span>,<span class="built_in">times</span>=1,<span class="built_in">type</span>=1):</span><br><span class="line"><span class="comment">#创建工作簿</span></span><br><span class="line">    wb = openpyxl.Workbook()</span><br><span class="line">    <span class="comment">#获取默认工作表</span></span><br><span class="line">    sheet = wb.active</span><br><span class="line">    <span class="comment">#重命名工作表名</span></span><br><span class="line">    sheet.title = sheetname</span><br><span class="line">    <span class="comment">#单元格赋值</span></span><br><span class="line">    sheet[<span class="string">&#x27;A1&#x27;</span>] = <span class="string">&#x27;序号&#x27;</span></span><br><span class="line">    sheet[<span class="string">&#x27;B1&#x27;</span>] = <span class="string">&#x27;设备id&#x27;</span></span><br><span class="line">    sheet[<span class="string">&#x27;C1&#x27;</span>] = <span class="string">&#x27;设备名称&#x27;</span></span><br><span class="line">    <span class="comment">#批量写入数据</span></span><br><span class="line">    n = 0</span><br><span class="line">    data_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">times</span>):</span><br><span class="line">        n += 1</span><br><span class="line">        dataid = n</span><br><span class="line">        deviceid = device_id()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == 1:</span><br><span class="line">            devicename = device_name()</span><br><span class="line">            data = [dataid, deviceid, devicename]</span><br><span class="line">            data_list.append(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            devicename2 = <span class="string">&#x27;设备名称&#x27;</span> + str(n)</span><br><span class="line">            data2 = [dataid, deviceid, devicename2]</span><br><span class="line">            data_list.append(data2)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> data_list:</span><br><span class="line">        sheet.append(row)</span><br><span class="line">    <span class="comment">#保存文件</span></span><br><span class="line">    wb.save(filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file = <span class="string">&#x27;/Users/alice0711/Desktop/practice.xlsx&#x27;</span></span><br><span class="line">    sheet = <span class="string">&#x27;sheet1&#x27;</span></span><br><span class="line">    import_file(filename=file,sheetname=sheet,<span class="built_in">times</span>=200,<span class="built_in">type</span>=2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="打开指定位置excel文件并写入"><a href="#打开指定位置excel文件并写入" class="headerlink" title="打开指定位置excel文件并写入"></a>打开指定位置excel文件并写入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  @Time : 2/22/22 2:25 AM</span></span><br><span class="line"><span class="comment">#  @Author : 柒仔</span></span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line">import openpyxl</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建设备id</span></span><br><span class="line">def device_id():</span><br><span class="line">    chars = string.ascii_letters + string.digits</span><br><span class="line">    deviceid = <span class="string">&#x27;&#x27;</span>.join((random.choice(chars) <span class="keyword">for</span> i <span class="keyword">in</span> range(random.randint(11, 512))))</span><br><span class="line">    <span class="built_in">return</span> deviceid</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成64位随机数</span></span><br><span class="line">def device_id64():</span><br><span class="line">    chars = string.ascii_letters + string.digits</span><br><span class="line">    devicename = <span class="string">&#x27;&#x27;</span>.join((random.choice(chars) <span class="keyword">for</span> i <span class="keyword">in</span> range(64)))</span><br><span class="line">    <span class="built_in">return</span> devicename</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机生成设备名称</span></span><br><span class="line">def device_name():</span><br><span class="line">    num = string.ascii_letters + string.digits</span><br><span class="line">    devicename = <span class="string">&#x27;&#x27;</span>.join((random.choice(num) <span class="keyword">for</span> i <span class="keyword">in</span> range(random.randint(1,64))))</span><br><span class="line">    <span class="built_in">return</span> devicename</span><br><span class="line"></span><br><span class="line">def output_file(filename,<span class="built_in">times</span>=1,devtype=True,<span class="built_in">type</span>=1,sheet_index=0,outfile=<span class="string">&#x27;demo.xlsx&#x27;</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    读取指定文件，并输出数据</span></span><br><span class="line"><span class="string">    :param filename: 读取的文件路径</span></span><br><span class="line"><span class="string">    :param times: 输出的数据行数</span></span><br><span class="line"><span class="string">    :param devtype: bool--True：范围随机位数；False：固定64位字符</span></span><br><span class="line"><span class="string">    :param type: 数据类型</span></span><br><span class="line"><span class="string">    :param sheet_index: 工作表索引</span></span><br><span class="line"><span class="string">    :param outfile: 输出的文件路径</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">#导入文件</span></span><br><span class="line">    wb = openpyxl.load_workbook(filename)</span><br><span class="line">    <span class="comment">#指定工作表</span></span><br><span class="line">    sheet = wb.worksheets[sheet_index]</span><br><span class="line">    <span class="comment">#根据需求生成对应的批量数据</span></span><br><span class="line">    n = 0</span><br><span class="line">    data_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">times</span>):</span><br><span class="line">        n += 1</span><br><span class="line">        dataid = n</span><br><span class="line">        <span class="keyword">if</span> devtype is True:</span><br><span class="line">            deviceid = device_id()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            deviceid = device_id64()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == 1:</span><br><span class="line">            devicename = device_name()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            devicename = <span class="string">&#x27;设备名称&#x27;</span> + str(n)</span><br><span class="line">        data = [dataid, deviceid, devicename]</span><br><span class="line">        data_list.append(data)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> data_list:</span><br><span class="line">        sheet.append(row)</span><br><span class="line">    wb.save(outfile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file = <span class="string">&#x27;/Users/alice0711/Desktop/practice2.xlsx&#x27;</span></span><br><span class="line">    outfile = <span class="string">&#x27;/Users/alice0711/Desktop/practice3.xlsx&#x27;</span></span><br><span class="line">    output_file(filename=file,<span class="built_in">times</span>=3,<span class="built_in">type</span>=2,devtype=False,outfile=outfile)</span><br><span class="line">    <span class="comment"># wb = openpyxl.load_workbook(outfile)</span></span><br><span class="line">    <span class="comment"># sheet = wb.worksheets[0]</span></span><br><span class="line">    <span class="comment"># id_len = sheet.cell(2,2).value</span></span><br><span class="line">    <span class="comment"># print(len(id_len))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;运用openpyxl模块完成文件内容的批量写入excel操作&lt;br&gt;确保本地存在openpyxl模块&lt;br&gt;若不存在：pip install openpyxl&lt;br&gt;1.新建excel文件，并写入数据，保存至指定位置&lt;br&gt;2.打开已存在的excel文件，追加写入内容&lt;/p</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【软件测试基础】知识精要</title>
    <link href="http://example.com/2022/02/21/%E3%80%90%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%9F%A5%E8%AF%86%E7%B2%BE%E8%A6%81/"/>
    <id>http://example.com/2022/02/21/%E3%80%90%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%9F%A5%E8%AF%86%E7%B2%BE%E8%A6%81/</id>
    <published>2022-02-20T16:15:21.000Z</published>
    <updated>2022-04-10T18:34:31.770Z</updated>
    
    <content type="html"><![CDATA[<p>一篇读书笔记，针对软件测试工程师<br>内容来源–《测试工程师全栈技术进阶与实践》</p><h2 id="功能性测试与非功能性测试"><a href="#功能性测试与非功能性测试" class="headerlink" title="功能性测试与非功能性测试"></a>功能性测试与非功能性测试</h2><ol><li><p>功能性测试<br> 最常用，最典型的黑盒测试方法：等价类划分法、边界值分析法<br> 针对显式功能性需求的验证：软件本身需要实现的具体功能，如“注册用户使用正确的用户名和密码可以成功登录”，“非注册用户无法登录”<br>除此之外还有隐式功能需求，以下：</p></li><li><p>安全性测试<br> 隐私性数据是否加密存储，如用户密码<br> 隐私性数据在网络传输过程中是否加密<br> 密码类数据是否存在有效期，到期后是否提示用户需要修改0.<br> 不登录的情况下，在浏览器地址栏中直接输入登录后的URL，是否重定向到登录页面<br> 加密显示的密码是否支持复制粘贴<br> 加密输入的密码在源码模式下是否会被查看到<br> 输入框中输入“sql注入攻击”字符串，验证系统返回的页面<br> 用户名和密码的输入框中分别输入典型的“跨站脚本攻击”字符串，验证系统的行为是否被篡改<br> 连续多次登录失败，账号是否被锁住<br> 同一用户在同一终端使用不同浏览器登录，验证登录功能的互斥性是否符合设计预期<br> 统一用户在不同终端登录，验证登录是否具有互斥性</p></li><li><p>性能压力测试<br> 接口响应时间，一般短于3s<br> 后台同时支持的请求数量<br> 高并发场景下，接口响应时间是否短于5s<br> 高并发场景下，服务端监控指标是否符合预期<br> 高集合点场景下，是否存在资源锁死和不合理的资源等待<br> 同一时间大量用户登录登出，服务端是否存在内存泄露</p></li><li><p>兼容性测试<br> 不同浏览器下同一页面功能和显示功能正确性<br> 相同浏览器不同版本下功能正确性<br> 不同移动终端不同浏览器，页面功能的正确性<br> 不同分辨率下，页面功能的正确性<br> ……</p></li></ol><h2 id="设计“好的”测试用例"><a href="#设计“好的”测试用例" class="headerlink" title="设计“好的”测试用例"></a>设计“好的”测试用例</h2><p>测试的不可穷尽性：在绝大多数情况下，是不可能进行穷尽测试的。<br>在绝大多数软件工程实践中，由于受限于实践成本和经济成本，不可穷尽测试，会采用基于风险驱动的模式，有所侧重的选择测试范围和设计测试用例，以寻求缺陷风险和研发成本之间的平衡。</p><p>问题思考；<br>什么是好的测试用例<br>用什么办法来量化测试用例发现缺陷的可能性<br>如何评估是否还存在未被发现的缺陷</p><p>“好的”用例一定是一个完备的集合，能够覆盖所有等价类以及各种边界值，而与能否发现缺陷无关。</p><h3 id="常用的测试用例设计方法："><a href="#常用的测试用例设计方法：" class="headerlink" title="常用的测试用例设计方法："></a>常用的测试用例设计方法：</h3><p>等价类划分法<br>边界值分析法<br>错误推测方法<br>因果图方法<br>判定表驱动分析法<br>正交实验设计方法<br>功能图分析方法<br>场景设计方法<br>形式化方法<br>拓展有限状态机方法等<br>但从软件企业实际的工程实践来说真正具有实用价值且常用的一般是前3种方法。<br>针对3种方法的核心概念以及使用时需要注意的问题：</p><ol><li>等价类划分法：从每个等价类中任意选取一个值进行测试，就可以用少量具有代表性的测试输入取得较好的测试覆盖结果。</li><li>边界值分析法：大量的程序错误发生在输入/输出的边界值上，所以需要对边界值进行重点测试。通常选取正好等于、刚刚大于或小于边界的值作为测试数据</li><li>错误推测方法：与现在流行的“探索性测试方法”的基本思想理念不谋而合，此类方法在目前的敏捷开发模式下投入的产出比很高，因此被广泛应用，并成为发现软件缺陷的主要方法。<br>例如：web界面GUI功能测试，需要考虑浏览器在有缓存和没有缓存下的表现；API测试需要考虑被测API所依赖的第三方API出错情况下的处理逻辑；对于代码级的单元测试，需要考虑被测函数的输入参数为空的情况下，内部处理逻辑等。</li></ol><p>在软件企业的具体实践中，为了降低对个人能力的依赖，通常会建立常见缺陷知识库，在测试设计的过程中，会使用缺陷库作为检查表（checklist）</p><h3 id="“好的”测试用例的设计方法"><a href="#“好的”测试用例的设计方法" class="headerlink" title="“好的”测试用例的设计方法"></a>“好的”测试用例的设计方法</h3><p>了解原始需求，从业务需求的角度去设计针对性明确，从终端用户使用场景考虑的端到端的测试用例集<br>思考过程：业务需求—&gt;软件功能需求—&gt;测试需求—&gt;测试用例<br>从软件功能需求出发，全面的识别出测试需求是关键，直接关系测试覆盖率<br>针对识别出来的测试需求点，综合运用这三种方法。</p><h2 id="单元测试的基础知识"><a href="#单元测试的基础知识" class="headerlink" title="单元测试的基础知识"></a>单元测试的基础知识</h2><h3 id="软件中的单元测试：对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，此处的最小单元通常是指函数或者类。"><a href="#软件中的单元测试：对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，此处的最小单元通常是指函数或者类。" class="headerlink" title="软件中的单元测试：对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，此处的最小单元通常是指函数或者类。"></a>软件中的单元测试：对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，此处的最小单元通常是指函数或者类。</h3><h3 id="单元测试的最佳实践："><a href="#单元测试的最佳实践：" class="headerlink" title="单元测试的最佳实践："></a>单元测试的最佳实践：</h3><h4 id="代码的基本特征：抛开代码需要实现的具体业务逻辑，仅看代码逻辑，所有的代码都是对数据进行分类处理"><a href="#代码的基本特征：抛开代码需要实现的具体业务逻辑，仅看代码逻辑，所有的代码都是对数据进行分类处理" class="headerlink" title="代码的基本特征：抛开代码需要实现的具体业务逻辑，仅看代码逻辑，所有的代码都是对数据进行分类处理"></a>代码的基本特征：抛开代码需要实现的具体业务逻辑，仅看代码逻辑，所有的代码都是对数据进行分类处理</h4><h4 id="代码产生错误的原因：代码分类存在遗漏"><a href="#代码产生错误的原因：代码分类存在遗漏" class="headerlink" title="代码产生错误的原因：代码分类存在遗漏"></a>代码产生错误的原因：代码分类存在遗漏</h4><h4 id="单元测试用例详解"><a href="#单元测试用例详解" class="headerlink" title="单元测试用例详解"></a>单元测试用例详解</h4><p>通常来说，单元测试的用例是一个“输入数据”和“预计输出”的集合。<br>总结的几种“输入数据”：<br>被测函数的输入参数；<br>被测函数内部需要读取的全局静态变量；<br>被测函数内部需要读取的成员变量；<br>在函数内部调用子函数获取的数据；</p><h2 id="自动化测试的原始驱动力和使用场景"><a href="#自动化测试的原始驱动力和使用场景" class="headerlink" title="自动化测试的原始驱动力和使用场景"></a>自动化测试的原始驱动力和使用场景</h2><h3 id="自动化测试的基本概念"><a href="#自动化测试的基本概念" class="headerlink" title="自动化测试的基本概念"></a>自动化测试的基本概念</h3><p>什么是自动化测试？<br>顾名思义，自动化测试是把人对软件的测试行为转化为由机器执行测试行为的一种实践。<br>自动化测试的本质是先编写一段代码，然后测试另一段代码，所以实现自动化测试用例本身属于开发工作，需要投入大量时间和精力。<br>已经完成的测试用例必须随着被测对象的改变而不断更新，还需为此付出维护测试用例的成本。<br>当自动化测试用例的维护成本高于其节省的测试成本时，自动化测试就失去了价值与意义，就需要在是否使用自动化测试上权衡取舍。</p><h3 id="自动化测试的优势与劣势"><a href="#自动化测试的优势与劣势" class="headerlink" title="自动化测试的优势与劣势"></a>自动化测试的优势与劣势</h3><p>优势：</p><ol><li>替代大量手工机械重复性操作</li><li>大幅提升回归测试的效率，非常适合敏捷开发</li><li>自动化测试可以更好的利用无人值守时间，更频繁的执行测试，非工作时间执行测试、工作时间分析失败用例。</li><li>自动化测试可以高效实现某些手工测试无法完成或者代价巨大的测试，如：关键业务7x24h持续运行的系统稳定性测试和高并发场景下的压力测试等。</li><li>保证每次测试执行的操作以及验证的一致性和可重复性</li></ol><p>劣势：</p><ol><li>自动化测试并不能取代手工测试，只能替代手工测试中执行频率高、机械化的重复步骤。</li><li>远比手工测试脆弱，无法应对被测系统的变化：“开发人员手一抖，自动化测试忙一宿”。维护成本居高不下的原因：自动化测试本身不具有任何“智能”</li><li>自动化测试用例的开发工作量远大于单次的手工测试</li><li>手工测试发现的缺陷数量通常比自动化测试要更多，且自动化测试的测试返回局限于回归测试范围-历史功能</li><li>自动化测试的效率很大程度上依赖自动化测试用例的设计以及实现的质量。</li><li>实现自动化测试的初期，用例开发效率通常很低，在整个自动化测试体系成熟且测试工程师全面掌握测试工具后，大量初期开发的测试用例都需哟重构。</li><li>业务测试专家和自动化测试专家通常是两批人。前者更懂业务，后者更懂自动化测试技术。只有两者紧密合作才能高效开展自动化测试。</li><li>自动化测试开发人员必须具备一定的编程能力。</li></ol><h3 id="自动化测试的使用场景"><a href="#自动化测试的使用场景" class="headerlink" title="自动化测试的使用场景"></a>自动化测试的使用场景</h3><ol><li>需求稳定、不会频繁变更的场景</li><li>研发和维护周期长，需要频繁执行回归测试</li><li>需要在多种平台上重复运行相同测试的场景<br> 例如：<br> 1）对于GUI测试，同样的测试用例需要在多种不同的浏览器上执行<br> 2）对于移动端应用测试，同样的测试用例需要在多个不同的Android或者ios版本上执行，或是不同的移动终端上执行<br> 3）对于一些企业级软件，若对不同的客户有不同的定制版本，各个定制版本的主体功能绝大多数是一致，测试也需要覆盖每个定制版本的所有功能。<br> 4）通过手工测试无法实现或者手工测试成本太高的测试项目；如：通过脚本生成大量数据用于测试文件导入数量限制；又比如实现1w名并发用户的基准性能测试<br> 5）被测软件的开发较为规范并且能够保证系统可测试性的场景<br> 6）测试人员具备一定编程能力<br>综上：自动化测试是一把“双刃剑”，一定程度上解放测试工程师的劳动力，完成一些人工无法实现的测试，单无法覆盖所有场景。若自动化测试的代价&gt;节省的测试成本，在这样的项目中推进自动化测试会得不偿失。</li></ol><h2 id="软件开发各阶段的自动化测试"><a href="#软件开发各阶段的自动化测试" class="headerlink" title="软件开发各阶段的自动化测试"></a>软件开发各阶段的自动化测试</h2><h3 id="单元测试的自动化技术"><a href="#单元测试的自动化技术" class="headerlink" title="单元测试的自动化技术"></a>单元测试的自动化技术</h3><h3 id="代码集成测试的自动化技术"><a href="#代码集成测试的自动化技术" class="headerlink" title="代码集成测试的自动化技术"></a>代码集成测试的自动化技术</h3><h3 id="web-service测试自动化技术"><a href="#web-service测试自动化技术" class="headerlink" title="web service测试自动化技术"></a>web service测试自动化技术</h3><h3 id="GUI测试的自动化技术"><a href="#GUI测试的自动化技术" class="headerlink" title="GUI测试的自动化技术"></a>GUI测试的自动化技术</h3><h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><h3 id="需求覆盖率"><a href="#需求覆盖率" class="headerlink" title="需求覆盖率"></a>需求覆盖率</h3><h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><h3 id="代码覆盖率的价值"><a href="#代码覆盖率的价值" class="headerlink" title="代码覆盖率的价值"></a>代码覆盖率的价值</h3><h3 id="代码覆盖率的局限性"><a href="#代码覆盖率的局限性" class="headerlink" title="代码覆盖率的局限性"></a>代码覆盖率的局限性</h3><h3 id="代码覆盖率报告"><a href="#代码覆盖率报告" class="headerlink" title="代码覆盖率报告"></a>代码覆盖率报告</h3><h3 id="代码覆盖率工具的实现技术"><a href="#代码覆盖率工具的实现技术" class="headerlink" title="代码覆盖率工具的实现技术"></a>代码覆盖率工具的实现技术</h3><h2 id="高效撰写软件缺陷报告（bug单）"><a href="#高效撰写软件缺陷报告（bug单）" class="headerlink" title="高效撰写软件缺陷报告（bug单）"></a>高效撰写软件缺陷报告（bug单）</h2><p>缺陷报告的质量直接关系到缺陷修复速度以及开发工程师的效率，还会影响测试与开发人员写作的有效性。<br>好的缺陷报告不是大量信息的堆叠，而是提供准确有用的信息。<br>bug对于大部分行业从业者来说是最熟悉不过的东西，本文章不做过多说明，仅简述主要内容。</p><h3 id="缺陷标题"><a href="#缺陷标题" class="headerlink" title="缺陷标题"></a>缺陷标题</h3><p>缺陷标题本身就要能概括性地描述具体问题，就可以通过阅读标题判断类似的缺陷是否提交过，大大提高测试工程师提交缺陷报告的效率。<br>标题应尽可能描述问题本质。</p><h3 id="缺陷概述"><a href="#缺陷概述" class="headerlink" title="缺陷概述"></a>缺陷概述</h3><p>是对缺陷标题的细化。<br>目的：清晰简洁地描述缺陷，使开发工程师能够聚焦缺陷的本质。</p><h3 id="缺陷影响"><a href="#缺陷影响" class="headerlink" title="缺陷影响"></a>缺陷影响</h3><p>描述缺陷引起的问题对用户或业务的影响范围以及严重程度。<br>缺陷影响决定缺陷优先级（priority）和严重程度（serverity）。开发经理以此为依据决定修复优先级，产品经理以此衡量缺陷的严重程度，决定是否要等该缺陷被修复后才发布产品。<br>但是准确描述缺陷影响的前提是，必须对软件的应用场景以及需求有深入了解，也是对测试工程师业务基本功的考验。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>用于详细描述环境的配置细节，为缺陷的重现提供必要的环境信息。例如：操作系统类型与版本，被测软件版本、浏览器的种类和版本，被测软件的配置星系，集群的配置参数，中间件的版本信息等。</p><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>即测试步骤开始前系统处于的状态，目的是减少缺陷重现步骤的描述，使bug描述更具有针对性。</p><h3 id="缺陷重现步骤"><a href="#缺陷重现步骤" class="headerlink" title="缺陷重现步骤"></a>缺陷重现步骤</h3><p>整个缺陷报告最核心的内容。目的在于用简洁的语言向开发工程师展示缺陷重现的具体操作步骤。每一步骤都应该是可操作并且是连贯的。<br>需确保缺陷的可重现性，并找到最短的重现路径，过滤掉非必要的步骤，避免产生不必要的干扰。<br>尽量避免以下3个常见问题：</p><ol><li>笼统的描述。缺乏可操作的具体步骤</li><li>出现与缺陷重现不相关的步骤</li><li>缺乏对测试数据的相关描述</li></ol><h3 id="期望结果和实际结果"><a href="#期望结果和实际结果" class="headerlink" title="期望结果和实际结果"></a>期望结果和实际结果</h3><p>期望结果来自于对需求的理解，实际结果来自于测试执行的结果。</p><h3 id="优先级和严重程度"><a href="#优先级和严重程度" class="headerlink" title="优先级和严重程度"></a>优先级和严重程度</h3><p>缺陷优先级：缺陷被修复的紧急程度<br>缺陷严重程度：因缺陷引起的故障对软件产品的影响程度<br>综上，严重程度是缺陷本身的属性，通常在确定后不再变化，优先级是缺陷的工程属性，会随着项目进度，解决缺陷的成本等因素变动。<br>两者的关系：</p><ol><li>缺陷越严重，优先级越高</li><li>缺陷影响范围越大，优先级越高</li><li>有些缺陷虽从用户角度来说不算严重，但是会妨碍测试或者自动化测试的执行，这类缺陷的严重程度低，但优先级高。</li><li>有些缺陷虽严重程度高，但考虑到修复成本以及技术难度，同时存在变通方案，也会出现优先级低的情况。</li></ol><h3 id="变通方案"><a href="#变通方案" class="headerlink" title="变通方案"></a>变通方案</h3><p>workaround，提供一种临时绕开当前缺陷但不影响产品功能的解决问题方式。<br>变通方案与实施方案，是决定缺陷优先级的重要依据。<br>若某个严重的问题没有任何的变通方案，则无论修复缺陷的代价多大，优先级是最高的，若该缺陷存在比较简单的变通方案，优秀级不一定会高。</p><h3 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h3><p>Root Cause Analysis，即RCA。若能再发现缺陷的同时定位出问题的根本原因，清楚的描述缺陷产生的原因并反馈给开发工程师，则修复效率大幅提升。<br>能做好根因分析的测试工程师多具备开发背景，或具备较好的代码阅读能力以及代码调试能力。<br>很有必要深入学习一门高级语言，系统的建立编程思想。</p><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>Attachment，提供缺陷的证据，如截图，测试用例日志，服务器端日志，GUI测试的执行视频等。</p><h2 id="做好测试计划"><a href="#做好测试计划" class="headerlink" title="做好测试计划"></a>做好测试计划</h2><h3 id="没有测试计划的后果"><a href="#没有测试计划的后果" class="headerlink" title="没有测试计划的后果"></a>没有测试计划的后果</h3><ol><li>很难确切的知道具体的测试范围以及应该采取的具体测试策略</li><li>很难预估具体的工作量和需要的测试工程师数量，同时会造成各个测试工程师分工不明确，导致部分测试工作重复执行而有的被遗漏。</li><li>测试的整体进度完全不可控，难以明细的知晓当前测试的完成情况，测试完成时间更难预估。</li><li>整个项目对潜在风险的抵抗能力很弱，难以应对需求的变更以及其他突发事件。</li></ol><h3 id="测试范围"><a href="#测试范围" class="headerlink" title="测试范围"></a>测试范围</h3><p>即被测对象以及主要的测试内容。<br>测试范围的确定通常在测试需求分析完成后进行，所以确定测试范围的过程一定程度上也是对测试需求分析的进一步检验。有利于在早期阶段发现潜在的测试疏漏。<br>不可能进行穷尽测试，且测试时间和资源都有限，因此必须有所取舍，进行针对性测试，在测试范围中需要明确“测试什么”和“不测试什么”。</p><h3 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h3><p>简单来说，即“先测试什么后测试什么”和“如何来测试”<br>测试策略需说明，采用什么养的测试类型和测试方法-即不仅要给出为什么要选用这个测试类型，还要详细说明具体的实施方法。</p><ol><li><p>功能测试<br>对于功能测试，应该根据测试需求分析的思维导图来设计测试用例。<br>因主线业务的功能测试经常需要执行回归测试，所以需要考虑实现自动化测试，并根据项目技术栈和测试团队成语的习惯与能力来选择合适的自动化测试框架。<br>主要的功能点，决定哪些测试点适合采用自动化测试，并决定使用什么样的框架技术。<br>评估被测软件的可测试性，有可测试性的问题，需要提前考虑切实可行的变通方案，甚至要求开发人员提供可测试的接口。</p></li><li><p>兼容性测试<br>需要确定覆盖的浏览器类型和版本，移动设备测试需要确定覆盖的设备类型和具体系统版本IOS/Android的版本等。<br>how？<br>a. 通过大数据技术分析产品的历史数据，得出前30%的移动设备以及IOS/Android的版本列表，兼容测试只需覆盖这部分即可。<br>b. 对于一个全新的产品，可通过TalkingData这样的网站来查看目前主流的移动设备分辨率大小、IOS/Android版本等信息来确定信息范围。等功能基本稳定了，才会开始兼容性测试。<br>c. 针对特例，如前端引入新的前端框架或组件库，往往会先进行兼容性评估，以确保不会引入后期无法解决的兼容性问题。兼容性测试用例的选取往往依据已经实现的自动化测试用例。</p></li><li><p>性能测试<br>需要在明确了性能需求（并发用户数、响应时间、事务吞吐量等）的前提下，结合被测系统的特点，设计性能测场景并确定性能测试框架。<br>例如：<br>是直接在API级别发起压力测试，还是必须模拟终端用户行为进行基于协议的压力测试。<br>是基于模块进行压力测试，还是发起全链路压测。<br>若性能是基于数据敏感的场景，还需要确定场景的数量与分布，并决定产生数据的技术方案，例如：<br>是通过API并发调用来产生产生测试数据，还是直接在数据库上做批量插入和更新操作，亦或是两者结合。<br>无论哪种，都需要明确待开发的单用户脚本数量，以便后续能够顺利确定压测场景。<br>脚本开发完成后，还要以脚本为单位组织测试场景。场景定义简单来说就是确定百分之所少的用户在做登录，百分之多少的用户在做查询，每个用户的操作步骤之间需要等待所少时间，并发用户的增速是5s一个还是5s两个等。</p></li></ol><p>拓展：<br>除了上述几种测试，还有很多测试类型，比如：接口测试，集成测试、安全测试，容量验证，安装测试，故障恢复测试等</p><h3 id="测试资源"><a href="#测试资源" class="headerlink" title="测试资源"></a>测试资源</h3><p>通常包括：测试人员和测试环境<br>资源有限，而测试计划的目的就是保证在有限资源下的产出最大化。<br>测试资源需要明确：1. 谁来测试；2. 在哪里测试<br>测试人员是最重要的资源，直接关系到整个测试项目的成败和效率。作为资源的测试人员通常有两个维度：</p><ol><li>测试工程师的数量</li><li>测试工程师的经验和能力<br>若测试工程师的经验和能力不足，通过测试人员数量的增加很难达到测试目的。<br>强烈建议把具体任务落实到每个人身上，有利于建立清晰的责任制，避免后续可能发生的争论。</li></ol><h3 id="测试进度"><a href="#测试进度" class="headerlink" title="测试进度"></a>测试进度</h3><p>主要描述各类测试的开始时间，所需工作量，预计完成时间，并以此为依据推算最终产品的上线和发布时间是否可以满足。如：版本接受测试（Build Acceptance Test）的工作量，冒烟测试（Smoke Test）的工作量，自动化脚本开发的工作量，缺陷修复的验证工作量，回归测试的轮数，每一轮回归测试的工作量等。<br>在敏捷模式下，测试活动贯穿于整个开发过程，很多测试工作会和开发工作同步进行<br>如，采用行为驱动开发（BDD：Behavior-Driven Development）模式或测试驱动开发模式，目的：测试进度不会完全依赖于提交可测试版本的时间。<br>行为驱动开发：通过自然语言书写非程序员可读的测试用例，并通过stepDef来关联基于自然语言的步骤描述和具体的业务操作，最典型的框架就是“Cucumber”</p><h3 id="测试风险预估"><a href="#测试风险预估" class="headerlink" title="测试风险预估"></a>测试风险预估</h3><h2 id="软件开发工程师需要掌握的非测试知识"><a href="#软件开发工程师需要掌握的非测试知识" class="headerlink" title="软件开发工程师需要掌握的非测试知识"></a>软件开发工程师需要掌握的非测试知识</h2><h2 id="互联网产品的测试策略设计"><a href="#互联网产品的测试策略设计" class="headerlink" title="互联网产品的测试策略设计"></a>互联网产品的测试策略设计</h2><h2 id="GUI自动化测试精要"><a href="#GUI自动化测试精要" class="headerlink" title="GUI自动化测试精要"></a>GUI自动化测试精要</h2><h2 id="移动应用测试技术"><a href="#移动应用测试技术" class="headerlink" title="移动应用测试技术"></a>移动应用测试技术</h2><h2 id="API自动化测试技术"><a href="#API自动化测试技术" class="headerlink" title="API自动化测试技术"></a>API自动化测试技术</h2><h2 id="代码级软件测试技术基础"><a href="#代码级软件测试技术基础" class="headerlink" title="代码级软件测试技术基础"></a>代码级软件测试技术基础</h2><h2 id="性能测试实战"><a href="#性能测试实战" class="headerlink" title="性能测试实战"></a>性能测试实战</h2><h2 id="自动化测试基础架构的建设与实践"><a href="#自动化测试基础架构的建设与实践" class="headerlink" title="自动化测试基础架构的建设与实践"></a>自动化测试基础架构的建设与实践</h2><h2 id="测试人员的互联网架构核心知识"><a href="#测试人员的互联网架构核心知识" class="headerlink" title="测试人员的互联网架构核心知识"></a>测试人员的互联网架构核心知识</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一篇读书笔记，针对软件测试工程师&lt;br&gt;内容来源–《测试工程师全栈技术进阶与实践》&lt;/p&gt;
&lt;h2 id=&quot;功能性测试与非功能性测试&quot;&gt;&lt;a href=&quot;#功能性测试与非功能性测试&quot; class=&quot;headerlink&quot; title=&quot;功能性测试与非功能性测试&quot;&gt;&lt;/a&gt;功</summary>
      
    
    
    
    
    <category term="软件测试理论" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识</title>
    <link href="http://example.com/2022/01/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/01/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-01-09T11:41:59.000Z</published>
    <updated>2022-02-01T17:31:15.186Z</updated>
    
    <content type="html"><![CDATA[<p>网络协议–计算机网络的核心<br>网络协议是为计算机网络中进行数据交换而建立的规则，标准或者说是约定的集合。不同用户的数据终端使用的字符集不同，两者需要进行通信，必须要在统一的标准上进行。<br>目前TCP/IP为计算机之前通信的常用语言。            </p><h2 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h2><p>为了使不同计算机厂家生产的计算机能够互相通信呢，以便在更大的范围内建立计算机网络，国际标准化组织(ISO)在1978年提出“开放系统互联参考模型”，即OSI/RM模型(Open System Interconnection/Reference Model)。<br>除了标准的OSI七层模型，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议。</p><p><img src="networkModel.png" alt="网络模型"></p><h2 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h2><p>任何和互联网有关的操作都离不开TCP/IP协议，无论是OSI七层模型还是TCP/IP四层，五层模型，每一层都有自己的专属协议，完成自己相应的工作以及上下层级之间进行沟通。OSI七层模型为网络的标准层次划分，所以以OSI七层模型为例<br><img src="osi.png" alt="OSI七层模型"></p><h3 id="物理层-Physical-Layer"><a href="#物理层-Physical-Layer" class="headerlink" title="物理层 Physical Layer"></a>物理层 Physical Layer</h3><p>确保原始的数据可在各种物理媒体上传输。<br>该层为上层协议提供了一个传输数据的可靠的物理媒体。激活，维持，关闭通信端点之间的机械特性，电气特性，功能特性以及过程特性。<br>两个重要的设备名称：中继器(Repeater) 集线器</p><h3 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层 Data Link Layer"></a>数据链路层 Data Link Layer</h3><p>在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层的数据可靠地传输到相邻节点的目标机网络层。<br>将数据组合成数据块，在数据链路层中称这种数据为帧(frame)，帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。<br>在不可靠的物理介质上提供可靠的传输，该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等</p><h4 id="数据链路层为网络层提供可靠的数据传输；"><a href="#数据链路层为网络层提供可靠的数据传输；" class="headerlink" title="数据链路层为网络层提供可靠的数据传输；"></a>数据链路层为网络层提供可靠的数据传输；</h4><h4 id="基本数据单位为帧"><a href="#基本数据单位为帧" class="headerlink" title="基本数据单位为帧"></a>基本数据单位为帧</h4><h4 id="主要的协议：以太网协议"><a href="#主要的协议：以太网协议" class="headerlink" title="主要的协议：以太网协议"></a>主要的协议：以太网协议</h4><h4 id="两个重要设备名称：网桥和交换机"><a href="#两个重要设备名称：网桥和交换机" class="headerlink" title="两个重要设备名称：网桥和交换机"></a>两个重要设备名称：网桥和交换机</h4><h3 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层 Network Layer"></a>网络层 Network Layer</h3><p>目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。<br>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议仅仅提供不可靠、无连接的传送服务。<br>IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。<br>重点：</p><h4 id="网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；"><a href="#网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；" class="headerlink" title="网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；"></a>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</h4><h4 id="基本数据单位为IP数据报；"><a href="#基本数据单位为IP数据报；" class="headerlink" title="基本数据单位为IP数据报；"></a>基本数据单位为IP数据报；</h4><h4 id="包含的主要协议："><a href="#包含的主要协议：" class="headerlink" title="包含的主要协议："></a>包含的主要协议：</h4><pre><code>    IP协议（Internet Protocol，因特网互联协议）    ICMP协议（Internet Control Message Protocol，因特网控制报文协议）    ARP协议（Address Resolution Protocol，地址解析协议）    RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）</code></pre><h4 id="重要的设备：路由器"><a href="#重要的设备：路由器" class="headerlink" title="重要的设备：路由器"></a>重要的设备：路由器</h4><h3 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层 Transport Layer"></a>传输层 Transport Layer</h3><p>第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。<br>重点：</p><h4 id="传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题"><a href="#传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题" class="headerlink" title="传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题"></a>传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题</h4><h4 id="包含的主要协议：TCP协议（Transmission-Control-Protocol，传输控制协议）、UDP协议（User-Datagram-Protocol，用户数据报协议）"><a href="#包含的主要协议：TCP协议（Transmission-Control-Protocol，传输控制协议）、UDP协议（User-Datagram-Protocol，用户数据报协议）" class="headerlink" title="包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）"></a>包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）</h4><h4 id="重要设备：网关"><a href="#重要设备：网关" class="headerlink" title="重要设备：网关"></a>重要设备：网关</h4><h3 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层 Session Layer"></a>会话层 Session Layer</h3><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步</p><h3 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层 Presentation Layer"></a>表示层 Presentation Layer</h3><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等</p><h3 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层 Application  Layer"></a>应用层 Application  Layer</h3><p>为操作系统或网络应用程序提供访问网络服务的接口<br>会话层、表示层和应用层重点：<br>    数据传输基本单位为报文<br>    包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h3><p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络</p><h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><p>广播地址通常称为直接广播地址，是为了区分受限广播地址<br>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1.当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息</p><h3 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h3><p>D类地址就是组播地址<br>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0<del>127.255.255.255；(modified @2016.05.31)<br>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0</del>191.255.255.255;<br>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0<del>223.255.255.255。<br>D类地址以1110开头，地址范围是224.0.0.0</del>239.255.255.255，D类地址作为组播地址（一对多的通信）；<br>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。<br>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><h3 id="255-255-255-255"><a href="#255-255-255-255" class="headerlink" title="255.255.255.255"></a>255.255.255.255</h3><p>指受限的广播地址<br>与一般广播地址区别：受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组<br>一般广播地址既可以在本地广播，也可卡网段广播，例：<br>主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报，若发送受限广播数据报，则不能收到。</p><h3 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h3><p>常用于寻找自己的IP地址，例如我们的RARP，BOOTP和DHCP协议中，若某个位置IP地址的无盘机想要知道自己的IP地址，就以255.255.255.255为目的地址，向本地范围（路由器屏蔽的范围内）的服务器发送IP请求分组。</p><h3 id="回环地址"><a href="#回环地址" class="headerlink" title="回环地址"></a>回环地址</h3><p>127.0.0.0/8被用作回环地址，即本机地址，常用于本机测试，用的最多的是127.0.0.1</p><h3 id="A，B，C类私有地址"><a href="#A，B，C类私有地址" class="headerlink" title="A，B，C类私有地址"></a>A，B，C类私有地址</h3><p>私有地址（private address），也叫专用地址，它们不会在全球使用，只具由本地意义。<br>A类私有地址：10.0.0.0/8，范围是：10.0.0.0<del>10.255.255.255<br>B类私有地址：172.16.0.0/12，范围是：172.16.0.0</del>172.31.255.255<br>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p><h2 id="子网掩码及网络划分"><a href="#子网掩码及网络划分" class="headerlink" title="子网掩码及网络划分"></a>子网掩码及网络划分</h2><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。<br>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><h3 id="什么是子网掩码？"><a href="#什么是子网掩码？" class="headerlink" title="什么是子网掩码？"></a>什么是子网掩码？</h3><p>子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。<br>在计算子网掩码时，我们要注意IP地址中的保留地址，即” 0”地址和广播地址，它们是指主机地址或网络地址全为” 0”或” 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</p><h3 id="子网掩码的计算："><a href="#子网掩码的计算：" class="headerlink" title="子网掩码的计算："></a>子网掩码的计算：</h3><p>对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。</p><p>下面总结一下有关子网掩码和网络划分常见的面试考题：</p><h4 id="利用子网数来计算"><a href="#利用子网数来计算" class="headerlink" title="利用子网数来计算"></a>利用子网数来计算</h4><p>在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。<br>(1) 将子网数目转化为二进制来表示;<br>如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；<br>(2) 取得该二进制的位数，为N；<br>该二进制为五位数，N = 5<br>(3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。<br>将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0<br>2）利用主机数来计算<br>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：<br>(1) 将主机数目转化为二进制来表示；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">700=1010111100</span><br></pre></td></tr></table></figure><p>(2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位；<br>该二进制为十位数，N=10；<br>(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。<br>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。<br>3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。<br>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10＋1＋1＋1＝13</span><br></pre></td></tr></table></figure><p>attention：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。<br>因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。<br>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p><h2 id="ARP-RARP协议"><a href="#ARP-RARP协议" class="headerlink" title="ARP/RARP协议"></a>ARP/RARP协议</h2><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。<br>ARP工作流程举例：<br>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；<br>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；<br>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><ul><li><pre><code>    （1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</code></pre></li><li><pre><code>    （2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</code></pre></li><li><pre><code>    （3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</code></pre></li><li><pre><code>    （4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</code></pre></li><li><pre><code>    （5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</code></pre>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址<br>，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。<br>RARP协议工作流程：</li><li><pre><code>    （1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</code></pre></li><li><pre><code>    （2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</code></pre></li><li><pre><code>    （3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</code></pre></li><li><pre><code>    （4）如果不存在，RARP服务器对此不做任何的响应</code></pre></li></ul><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>常见的路由选择协议有：RIP协议、OSPF协议。<br>RIP协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。<br>OSPF协议 ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟</p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。<br>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。<br>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用”带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为”滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。<br>TCP报文首部格式：<br><img src="TCP%E6%8A%A5%E6%96%87.png" alt="TCP报文"><br><img src="TCP_connect.png" alt="TCP三次握手四次挥手"><br>注：seq:”sequance”序列号；ack:”acknowledge”确认号；SYN:”synchronize”请求同步标志；；ACK:”acknowledge”确认标志”；FIN：”Finally”结束标志。<br>TCP连接建立过程：首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。<br>TCP连接断开过程：假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。”，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！<br>为什么要三次握手？<br>在只有两次”握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，”三次握手”很有必要！<br>为什么要四次挥手？<br>试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！<br>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。<br>UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。<br>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。<br>每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：</p><ul><li><pre><code>    （1）源端口号；</code></pre></li><li><pre><code>    （2）目标端口号；</code></pre></li><li><pre><code>    （3）数据报长度；</code></pre></li><li><pre><code>    （4）校验值。</code></pre>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。<br>TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务</li></ul><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务</p><h2 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h2><p>NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。　　HTTP 协议包括哪些请求？<br>GET：请求读取由URL所标志的信息。<br>POST：给服务器添加信息（如注释）。<br>PUT：在给定的URL下存储一个文档。<br>DELETE：删除给定的URL所标志的资源。<br>　　HTTP 中， POST 与 GET 的区别</p><ul><li><pre><code>    1）Get是从服务器上获取数据，Post是向服务器传送数据。</code></pre></li><li><pre><code>    2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</code></pre></li><li><pre><code>    3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。</code></pre></li><li><pre><code>    4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</code></pre></li><li><pre><code>    I. 所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</code></pre></li><li><pre><code>    II. 幂等 的意味着对同一URL的多个请求应该返回同样的结果。</code></pre></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在浏览器中输入 <a href="http://www.baidu.com/">http://www.baidu.com/</a> 后执行的全部过程。</p><p>现在假设如果我们在客户端（客户端）浏览器中输入 <a href="http://www.baidu.com,/">http://www.baidu.com，</a> 而 baidu.com 为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</p><p>1）客户端浏览器通过DNS解析到<a href="http://www.baidu.com的ip地址220.181.27.48,通过这个ip地址找到客户端到服务器的路径.客户端浏览器发起一个http会话到220.161.27.48,然后通过tcp进行封装数据包,输入到网络层./">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a><br>2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。<br>3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。<br>4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络协议–计算机网络的核心&lt;br&gt;网络协议是为计算机网络中进行数据交换而建立的规则，标准或者说是约定的集合。不同用户的数据终端使用的字符集不同，两者需要进行通信，必须要在统一的标准上进行。&lt;br&gt;目前TCP/IP为计算机之前通信的常用语言。            &lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>软件测试必备:linux常用命令</title>
    <link href="http://example.com/2022/01/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%BF%85%E5%A4%87-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/01/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%BF%85%E5%A4%87-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-03T02:21:57.000Z</published>
    <updated>2022-01-03T08:54:32.756Z</updated>
    
    <content type="html"><![CDATA[<p>常用的linux命令，大部分也适用于unix类系统，比如mac os</p><span id="more"></span><h2 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h2><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>访问目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> opt</span><br><span class="line"><span class="comment">#访问当前目录下的opt目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment">#返回上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> ../..</span><br><span class="line"><span class="comment">#返回上两集目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment">#进入个人主目录</span></span><br></pre></td></tr></table></figure><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>显示工作路径</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>查看目录中的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="comment">#查看当前目录中的文件</span></span><br><span class="line">ls -l  </span><br><span class="line"><span class="comment">#显示文件和目录的详细资料，也可使用ll</span></span><br><span class="line">ls -a </span><br><span class="line"><span class="comment">#显示隐藏文件</span></span><br><span class="line">ls *[0-9]* </span><br><span class="line"><span class="comment">#显示包含数字的文件名和目录名</span></span><br><span class="line">ls -lh</span><br><span class="line"><span class="comment">#显示权限</span></span><br></pre></td></tr></table></figure><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir1</span><br><span class="line"><span class="comment">#创建一个名为dir1的目录</span></span><br><span class="line">mkdir dir1 dir2 </span><br><span class="line"><span class="comment">#同时创建两个目录，若dir1已存在</span></span><br><span class="line">mkdir -p /tmp/dir1/dir2 </span><br><span class="line"><span class="comment">#创建一个目录树</span></span><br></pre></td></tr></table></figure><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>删除目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmdir dir1</span><br><span class="line"><span class="comment">#删除名为dir1的目录</span></span><br></pre></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -f file1 </span><br><span class="line"><span class="comment">#删除一个名为file1的文件</span></span><br><span class="line">rm -rf dir1 </span><br><span class="line"><span class="comment">#删除一个叫做 &#x27;dir1&#x27; 的目录并同时删除其内容</span></span><br><span class="line">rm -rf dir1 dir2 </span><br><span class="line"><span class="comment">#同时删除两个目录及它们的内容</span></span><br></pre></td></tr></table></figure><p>rm -rf /  高危操作，懂得都懂</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>重命名/移动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv dir1 new_dir </span><br><span class="line"><span class="comment">#移动dir1至new_dir下；若new_dir不存在则重命名dir1文件为new_dir</span></span><br></pre></td></tr></table></figure><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2 </span><br><span class="line"><span class="comment">#复制file1并命名为file2</span></span><br><span class="line">cp dir/* . </span><br><span class="line"><span class="comment">#复制一个目录下的所有文件到当前工作目录</span></span><br><span class="line">cp -a /tmp/dir1 . </span><br><span class="line"><span class="comment">#复制一个目录到当前工作目录</span></span><br><span class="line">cp -a dir1 dir2 </span><br><span class="line"><span class="comment">#复制目录dir1并命名为dir2</span></span><br></pre></td></tr></table></figure><h2 id="用户与群组"><a href="#用户与群组" class="headerlink" title="用户与群组"></a>用户与群组</h2><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>创建新用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd zhangsan</span><br><span class="line"><span class="comment">#创建名为zhangsan的用户</span></span><br></pre></td></tr></table></figure><p>passwd + 用户名：设置用户密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd zhangsan</span><br></pre></td></tr></table></figure><p>若passwd后面什么都不跟，则系统默认更改root用户的登录密码</p><p>设置普通用户的登录期限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -e 2022-12-31 zhangsan</span><br></pre></td></tr></table></figure><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>修改用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">usermod -e 2023-12-31 zhangsan</span><br><span class="line"><span class="comment">#修改zhangsan的登录期限</span></span><br><span class="line">usermod -d /home/hnlinux root</span><br><span class="line"><span class="comment">#修改登录目录</span></span><br><span class="line">usermod -u 777 root</span><br><span class="line"><span class="comment">#修改用户的uid</span></span><br><span class="line">usermod -l zhangsan xiaogang</span><br><span class="line"><span class="comment">#修改zhangsan的用户名为xiaogang</span></span><br><span class="line"><span class="comment">#-l:--login </span></span><br><span class="line">usermod -g 578 newgroup</span><br><span class="line"><span class="comment">#修改用户的gid，578组一定要存在</span></span><br><span class="line"><span class="comment">#-g:--gid</span></span><br><span class="line">usermod -aG usertest zhangsan</span><br><span class="line"><span class="comment">#将zhangsan加入usertest组</span></span><br><span class="line"><span class="comment">#-a：--append；-G:--groups</span></span><br><span class="line"><span class="built_in">kill</span> -9 -u zhangsan</span><br><span class="line"><span class="comment">#杀死zhangsan执行的所有进程</span></span><br><span class="line">usermod -L zhangsan</span><br><span class="line"><span class="comment">#锁定用户密码</span></span><br><span class="line"><span class="comment">#-L:--lock</span></span><br><span class="line">usermod -u zhangsan</span><br><span class="line"><span class="comment">#解锁用户密码</span></span><br><span class="line"><span class="comment">#-U:--unlock</span></span><br></pre></td></tr></table></figure><p>使用usermod修改信息时需要保证被修改的用户没有在系统中执行任何程序;usermod不允许修改正在线上的使用者账号名称</p><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p>删除用户账号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userdel -r zhangsan</span><br><span class="line"><span class="comment">#删除用户zhangsan及其相关文件</span></span><br><span class="line">userdel zhangsan</span><br><span class="line"><span class="comment">#仅删除zhangsan不删除其相关文件</span></span><br></pre></td></tr></table></figure><h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><p>创建用户组<br>用于创建新的工作组，新工作组中的信息将被添加至系统文件中<br>相关文件：<br>/etc/group 组账户信息<br>/etc/gshadow 安全组账户信息<br>/etc/login.defs Shadow 密码套件配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 344 grouptest</span><br><span class="line"><span class="comment">#创建新组名为grouptest，指定组ID：344；/etc/group文件中生成一个gid为344的项目</span></span><br></pre></td></tr></table></figure><h3 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h3><p>修改组信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groupmod -n grouptest newgroupname</span><br><span class="line"><span class="comment">#修改grouptest组名为newgroupname</span></span><br><span class="line"></span><br><span class="line">groupmod -g 444 grouptest</span><br><span class="line"><span class="comment">#修改组grouptest的gid为444</span></span><br></pre></td></tr></table></figure><h3 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h3><p>删除组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupdel grouptest</span><br><span class="line"><span class="comment">#删除组grouptes</span></span><br></pre></td></tr></table></figure><p>组中含有用户时，不能直接删除组，只能先删除组中的用户再删除组</p><p>###chage </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chage -E 2022-12-28 zhangsan</span><br><span class="line"><span class="comment">#设置zhangsna的密码于2022年12月30日过期</span></span><br><span class="line">chage -l 3 zhangsan</span><br><span class="line"><span class="comment">#设置zhangsan的密码从过期开始算起，3天不修改则密码失效</span></span><br></pre></td></tr></table></figure><p>密码过期&amp;密码失效<br>过期：密码到指定失效时间，系统会认为密码不安全，于是将密码设置为过期状态，用户登录时，提示用户进行密码修改<br>失效：用户密码失效后在指定时间内未进行修改，则系统将改密码设置为失效状态，用户则无法通过此密码登录</p><h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">find / -name file1 </span><br><span class="line"><span class="comment">#从 &#x27;/&#x27; 开始进入根文件系统搜索文件和目录</span></span><br><span class="line">find / -user user1 </span><br><span class="line"><span class="comment">#搜索属于用户 &#x27;user1&#x27; 的文件和目录</span></span><br><span class="line">find /home/user1 -name \*.bin </span><br><span class="line"><span class="comment">#在目录 &#x27;/ home/user1&#x27; 中搜索带有&#x27;.bin&#x27; 结尾的文件</span></span><br><span class="line">find /usr/bin -<span class="built_in">type</span> f -atime +100 </span><br><span class="line"><span class="comment">#搜索在过去100天内未被使用过的执行文件</span></span><br><span class="line">find /usr/bin -<span class="built_in">type</span> f -mtime -10 </span><br><span class="line"><span class="comment">#搜索在10天内被创建或者修改过的文件</span></span><br><span class="line">find / -name \*.rpm -<span class="built_in">exec</span> chmod 755 <span class="string">&#x27;&#123;&#125;&#x27;</span> \; </span><br><span class="line"><span class="comment">#搜索以 &#x27;.rpm&#x27; 结尾的文件并定义其权限</span></span><br><span class="line">find / -xdev -name \*.rpm </span><br><span class="line"><span class="comment">#搜索以 &#x27;.rpm&#x27; 结尾的文件，忽略光驱、捷盘等可移动设备</span></span><br></pre></td></tr></table></figure><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>只能用于查找符合条件的二进制文件、源代码文件和man手册页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereid bash</span><br><span class="line"><span class="comment">#查找bash的位置</span></span><br></pre></td></tr></table></figure><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>在环境变量$PATH设置的目录中寻找符合条件的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> bash</span><br><span class="line"><span class="comment">#寻找bash文件并显示其绝对路径</span></span><br></pre></td></tr></table></figure><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><ul><li>设置权限</li></ul><ul><li>取消权限<br>此命令对root无效<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+rwx directory1 </span><br><span class="line"><span class="comment">#设置目录为所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</span></span><br><span class="line">chmod go-rwx directory1 </span><br><span class="line"><span class="comment">#删除群组(g)与其他人(o)对目录的读写执行权限</span></span><br></pre></td></tr></table></figure>修改权限的两种方式：</li></ul><p>1.字母：r-可读；w-可写；x-可执行；<br>2.数字：<br>0:—<br>1:–x<br>2:-w-<br>3:-wx<br>4:r–<br>5:r-x<br>6:rw-<br>7:rwx<br>ll or ls -l查看文件属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[alicedeMBP:blog alice0711]$ ls -l</span><br><span class="line">-rw-r--r--    1 alice0711  staff       0 12  9 02:30 _config.landscape.yml</span><br></pre></td></tr></table></figure><p>以上文件属性 -|rw-|r–|r– 以｜为分隔符，依次为：文件类型[-代表文件；d代表目录]｜文件所有者权限｜文件所有者所在组的用户权限｜其他用户权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx file1</span><br><span class="line"><span class="comment">#将file1的用户权限修改为可读可写可执行</span></span><br><span class="line">chomd 777 file1</span><br><span class="line"><span class="comment">#将file2的用户，群组，其他用户的权限都修改为可读可写可执行</span></span><br></pre></td></tr></table></figure><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>修改文件所有者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chown user1 file1 </span><br><span class="line"><span class="comment">#改变一个文件的所有人</span></span><br><span class="line">chown -R user1 directory1 </span><br><span class="line"><span class="comment">#改变directory1目录下所有文件，目录的所有者为user1</span></span><br></pre></td></tr></table></figure><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>修改文件的群组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp group1 file1</span><br><span class="line"><span class="comment">#将file1所属群组修改为group1</span></span><br></pre></td></tr></table></figure><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat file1 </span><br><span class="line"><span class="comment">#从第一个字节开始正向查看文件的内容</span></span><br><span class="line">tac file1 </span><br><span class="line"><span class="comment">#从最后一行开始反向查看一个文件的内容</span></span><br><span class="line">more file1 </span><br><span class="line"><span class="comment">#查看一个长文件的内容</span></span><br><span class="line">less file1 </span><br><span class="line"><span class="comment">#类似于 &#x27;more&#x27; 命令，但是它允许在文件中和正向操作一样的反向操作</span></span><br><span class="line">head -2 file1 </span><br><span class="line"><span class="comment">#查看一个文件的前两行</span></span><br><span class="line">tail -2 file1 </span><br><span class="line"><span class="comment">#查看一个文件的最后两行</span></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/messages </span><br><span class="line"><span class="comment">#实时查看被添加到一个文件中的内容,tailf</span></span><br></pre></td></tr></table></figure><h2 id="编辑文件vi-vim"><a href="#编辑文件vi-vim" class="headerlink" title="编辑文件vi/vim"></a>编辑文件vi/vim</h2><p>所有的 Unix Like 系统都会内建 vi 文书编辑器<br>Vim 是从 vi 发展出来的一个文本编辑器，vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。<br>vim 则可以说是程序开发者的一项很好用的工具。连 vim 的<a href="http://www.vim.org/">官方网站</a>自己也说 vim 是一个程序开发工具而不是文字处理软件。</p><h3 id="vi-vim的使用"><a href="#vi-vim的使用" class="headerlink" title="vi/vim的使用"></a>vi/vim的使用</h3><p>vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：</p><h4 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h4><dl><dt>用户刚刚启动 vi/vim，便进入了命令模式。<br>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。<br>常用的几个命令：<br>i 切换到输入模式，以输入字符。<br>x 删除当前光标所在处的字符。</dt><dd>切换到底线命令模式，以在最底一行输入命令。<br>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。<br>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</dd></dl><h4 id="输入模式："><a href="#输入模式：" class="headerlink" title="输入模式："></a>输入模式：</h4><p>在命令模式下按下i就进入了输入模式。<br>在输入模式中，可以使用以下按键：<br>字符按键以及Shift组合，输入字符<br>ENTER，回车键，换行<br>BACK SPACE，退格键，删除光标前一个字符<br>DEL，删除键，删除光标后一个字符<br>方向键，在文本中移动光标<br>HOME/END，移动光标到行首/行尾<br>Page Up/Page Down，上/下翻页<br>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线<br>ESC，退出输入模式，切换到命令模式</p><h4 id="底线命令模式："><a href="#底线命令模式：" class="headerlink" title="底线命令模式："></a>底线命令模式：</h4><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。<br>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。<br>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q <span class="comment">#退出程序</span></span><br><span class="line">w <span class="comment">#保存文件</span></span><br><span class="line">wq <span class="comment">#保存并退出文件</span></span><br><span class="line">!q <span class="comment">#强制退出，不保存修改</span></span><br></pre></td></tr></table></figure><p>搜索替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/word <span class="comment">#向光标之下寻找一个名为word的字符串</span></span><br><span class="line">?word <span class="comment">#向光标之上寻找一个名为word的字符串</span></span><br></pre></td></tr></table></figure><p>配合n、N按键寻找关键词<br>/word+n：搜索到一个关键词后，继续向下搜寻关键词；<br>?word+n：搜索到一个关键词后，继续向上搜索关键词。<br>N与n相反</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:2,10s/word1/word2/g</span><br><span class="line"><span class="comment">#从第2行至第10行寻找word1，并将word1替换为word2</span></span><br><span class="line">:3,<span class="variable">$s</span>/word1/word2/g</span><br><span class="line"><span class="comment">#从第3行至第最后一行寻找word1，并将word1替换为word2</span></span><br><span class="line">:1,<span class="variable">$s</span>/word1/word2/gc </span><br><span class="line"><span class="comment">#or </span></span><br><span class="line">:%s/word1/word2/gc</span><br><span class="line"><span class="comment">#从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代!</span></span><br></pre></td></tr></table></figure><p>删除、复制与粘贴<br>x, X<br>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键)<br>nx    n<br>为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符,『10x』。<br>dd<br>删除游标所在的那一整行c<br>ndd<br>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行<br>d1G<br>删除光标所在到第一行的所有数据<br>dG<br>删除光标所在到最后一行的所有数据<br>d$<br>删除游标所在处，到该行的最后一个字符<br>d0<br>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符<br>yy<br>复制游标所在的那一行<br>nyy    n<br>为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行<br>y1G<br>复制游标所在行到第一行的所有数据<br>yG<br>复制游标所在行到最后一行的所有数据<br>y0<br>复制光标所在的那个字符到该行行首的所有数据<br>y$<br>复制光标所在的那个字符到该行行尾的所有数据<br>p, P<br>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后，那10行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)<br>J<br>将光标所在行与下一行的数据结合成同一行<br>c<br>重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br>u<br>复原前一个动作<br>[Ctrl]+r<br>重做上一个动作</p><p>按ESC键可随时退出底线命令模式。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 </span><br><span class="line"><span class="comment">#显示一个以太网卡的配置</span></span><br><span class="line">ifup eth0 </span><br><span class="line"><span class="comment">#启用一个 &#x27;eth0&#x27; 网络设备</span></span><br><span class="line">ifdown eth0 </span><br><span class="line"><span class="comment">#禁用一个 &#x27;eth0&#x27; 网络设备</span></span><br><span class="line">ifconfig eth0 192.168.1.1 netmask 255.255.255.0 </span><br><span class="line"><span class="comment">#控制IP地址</span></span><br></pre></td></tr></table></figure><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat -tup </span><br><span class="line"><span class="comment">#展示所有进行中的网络连接和他们的PID</span></span><br><span class="line"><span class="comment">#-t:--tcp 显示TCP传输协议的连接状况</span></span><br><span class="line"><span class="comment">#-u:--udp 显示UDP传输协议的连接状况</span></span><br><span class="line"><span class="comment">#-p:--programs 显示正在使用Socket的程序识别码和程序名称</span></span><br><span class="line">netstat -tupl </span><br><span class="line"><span class="comment">#展示系统中左右监听的网络服务和他们的PID</span></span><br><span class="line"><span class="comment">#-l:--listening:显示监听中的服务器的socket</span></span><br></pre></td></tr></table></figure><h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><p>查看8080端口号的占用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">losf -i:8080</span><br></pre></td></tr></table></figure><p>杀死进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 26993</span><br><span class="line"><span class="comment">#杀死pid为26993的进程</span></span><br></pre></td></tr></table></figure><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date </span><br><span class="line"><span class="comment">#显示系统日期</span></span><br><span class="line">cal 2021 </span><br><span class="line"><span class="comment">#显示2021年的日历表</span></span><br><span class="line">date 123117002021.00 </span><br><span class="line"><span class="comment">#设置日期和时间 - 月日时分年.秒</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo </span><br><span class="line"><span class="comment">#显示CPU info的信息</span></span><br><span class="line">cat /proc/interrupts </span><br><span class="line"><span class="comment">#显示中断</span></span><br><span class="line">cat /proc/meminfo </span><br><span class="line"><span class="comment">#校验内存使用</span></span><br><span class="line">cat /proc/swaps </span><br><span class="line"><span class="comment">#显示哪些swap被使用</span></span><br><span class="line">cat /proc/version </span><br><span class="line"><span class="comment">#显示内核的版本</span></span><br><span class="line">cat /proc/net/dev </span><br><span class="line"><span class="comment">#显示网络适配器及统计</span></span><br><span class="line">cat /proc/mounts </span><br><span class="line"><span class="comment">#显示已加载的文件系统</span></span><br><span class="line">lspci -tv </span><br><span class="line"><span class="comment">#罗列 PCI 设备</span></span><br><span class="line">lsusb -tv </span><br><span class="line"><span class="comment">#显示 USB 设备</span></span><br></pre></td></tr></table></figure><h2 id="系统关机、重启、登出"><a href="#系统关机、重启、登出" class="headerlink" title="系统关机、重启、登出"></a>系统关机、重启、登出</h2><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">init 0</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">telinit 0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h hours:minutes &amp; </span><br><span class="line"><span class="comment">#按预定时间关闭系统</span></span><br><span class="line">shutdown -c </span><br><span class="line"><span class="comment">#取消按预定时间关闭系统</span></span><br></pre></td></tr></table></figure><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">logout</span></span><br></pre></td></tr></table></figure><h2 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df -h </span><br><span class="line"><span class="comment">#显示已经挂载的分区列表</span></span><br><span class="line">ls -lSr |more </span><br><span class="line"><span class="comment">#以尺寸大小排列文件和目录</span></span><br><span class="line">du -sh dir1 </span><br><span class="line"><span class="comment">#估算目录dir1已经使用的磁盘空间</span></span><br><span class="line">du -sk * | sort -rn </span><br><span class="line"><span class="comment">#以容量大小为依据依次显示文件和目录的大小</span></span><br></pre></td></tr></table></figure><h2 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">bunzip2 file1.bz2 </span><br><span class="line"><span class="comment">#解压一个叫做 &#x27;file1.bz2&#x27;的文件</span></span><br><span class="line">bzip2 file1 </span><br><span class="line"><span class="comment">#压缩一个叫做 &#x27;file1&#x27; 的文件</span></span><br><span class="line">gunzip file1.gz </span><br><span class="line"><span class="comment">#解压一个叫做 &#x27;file1.gz&#x27;的文件</span></span><br><span class="line">gzip file1 </span><br><span class="line"><span class="comment">#压缩一个叫做 &#x27;file1&#x27;的文件</span></span><br><span class="line">gzip -9 file1 </span><br><span class="line"><span class="comment">#最大程度压缩</span></span><br><span class="line">rar a file1.rar test_file </span><br><span class="line"><span class="comment">#创建一个叫做 &#x27;file1.rar&#x27; 的包</span></span><br><span class="line">rar a file1.rar file1 file2 dir1 </span><br><span class="line"><span class="comment">#同时压缩 &#x27;file1&#x27;, &#x27;file2&#x27; 以及目录 &#x27;dir1&#x27;</span></span><br><span class="line">rar x file1.rar </span><br><span class="line"><span class="comment">#解压rar包</span></span><br><span class="line">unrar x file1.rar </span><br><span class="line"><span class="comment">#解压rar包</span></span><br><span class="line">tar -cvf archive.tar file1 </span><br><span class="line"><span class="comment">#创建一个非压缩的 tarball</span></span><br><span class="line">tar -cvf archive.tar file1 file2 dir1 </span><br><span class="line"><span class="comment">#创建一个包含了 &#x27;file1&#x27;, &#x27;file2&#x27; 以及 &#x27;dir1&#x27;的档案文件</span></span><br><span class="line">tar -tf archive.tar </span><br><span class="line"><span class="comment">#显示一个包中的内容</span></span><br><span class="line">tar -xvf archive.tar </span><br><span class="line"><span class="comment">#释放一个包</span></span><br><span class="line">tar -xvf archive.tar -C /tmp </span><br><span class="line"><span class="comment">#将压缩包释放到 /tmp目录下</span></span><br><span class="line">tar -cvfj archive.tar.bz2 dir1 </span><br><span class="line"><span class="comment">#创建一个bzip2格式的压缩包</span></span><br><span class="line">tar -xvfj archive.tar.bz2 </span><br><span class="line"><span class="comment">#解压一个bzip2格式的压缩包</span></span><br><span class="line">tar -cvfz archive.tar.gz dir1 </span><br><span class="line"><span class="comment">#创建一个gzip格式的压缩包</span></span><br><span class="line">tar -xvfz archive.tar.gz </span><br><span class="line"><span class="comment">#解压一个gzip格式的压缩包</span></span><br><span class="line">zip file1.zip file1 </span><br><span class="line"><span class="comment">#创建一个zip格式的压缩包</span></span><br><span class="line">zip -r file1.zip file1 file2 dir1 </span><br><span class="line"><span class="comment">#将几个文件和目录同时压缩成一个zip格式的压缩包</span></span><br><span class="line">unzip file1.zip </span><br><span class="line"><span class="comment">#解压一个zip格式压缩包</span></span><br></pre></td></tr></table></figure><h2 id="yum-软件包升级"><a href="#yum-软件包升级" class="headerlink" title="yum 软件包升级"></a>yum 软件包升级</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yum install package_name </span><br><span class="line"><span class="comment">#下载并安装一个rpm包</span></span><br><span class="line">yum localinstall package_name.rpm </span><br><span class="line"><span class="comment">#将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</span></span><br><span class="line">yum update package_name.rpm </span><br><span class="line"><span class="comment">#更新当前系统中所有安装的rpm包</span></span><br><span class="line">yum update package_name </span><br><span class="line"><span class="comment">#更新一个rpm包</span></span><br><span class="line">yum remove package_name </span><br><span class="line"><span class="comment">#删除一个rpm包</span></span><br><span class="line">yum list </span><br><span class="line"><span class="comment">#列出当前系统中安装的所有包</span></span><br><span class="line">yum search package_name </span><br><span class="line"><span class="comment">#在rpm仓库中搜寻软件包</span></span><br><span class="line">yum clean packages </span><br><span class="line"><span class="comment">#清理rpm缓存删除下载的包</span></span><br><span class="line">yum clean headers </span><br><span class="line"><span class="comment">#删除所有头文件</span></span><br><span class="line">yum clean all </span><br><span class="line"><span class="comment">#删除所有缓存的包和头文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用的linux命令，大部分也适用于unix类系统，比如mac os&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git快速入门</title>
    <link href="http://example.com/2021/12/23/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2021/12/23/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2021-12-22T17:21:48.000Z</published>
    <updated>2021-12-22T17:56:04.757Z</updated>
    
    <content type="html"><![CDATA[<p>简单的git操作指南</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>git支持多操作系统，包括macos，windows，linux</p><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>本地创建新的文件夹，打开并执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h2><p>创建一个本地的克隆仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> /path/to/repository</span><br></pre></td></tr></table></figure><p>若克隆的是远程服务器上的仓库，则命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> username@host:/path/to/repository</span><br></pre></td></tr></table></figure><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>本地仓库由三部分组成：<br>1.工作目录:持有实际文件<br>｜<br>｜add<br>｜</p><p>2.暂存区(index)：一个缓存区域，临时保存你的改动<br>｜<br>｜commit<br>｜<br>3.HEAD：指向最后一次提交的结果</p><h2 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h2><p>提交更改-将内容添加至暂存区，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">git add *</span><br></pre></td></tr></table></figure><p>这是git基本工作流程的第一步；<br>提交实际改动，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;代码提交信息&quot;</span></span><br></pre></td></tr></table></figure><p>至此，你的改动已经提交到了HEAD，但是还没有传到远程仓库</p><h2 id="推动改动"><a href="#推动改动" class="headerlink" title="推动改动"></a>推动改动</h2><p>将存在本地仓库的HEAD的改动，提交至远程仓库，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>此处的master为主干名称，可以换成想要推送的任何分支</p><p>如果还没有克隆现有仓库，并打算将你的仓库连接到某个远程服务器，使用如下命令添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure><p>如此，就能将改动推送至所添加的服务器上</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是用来将特性开发绝缘开来的，在创建仓库的时候，master是默认的分支，在其他分支上进行开发，完成后再将它们合并到主分支上，也称之为合主干</p><p>创建一个叫做“feature_x”的分支。并切换过去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure><p>切换回主干：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>将新建的分支删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure><p>本地创建的分支除非被推送到远程仓库，否则该分支不为他人可见，推送分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure><h2 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h2><p>更新本地仓库，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。 这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>在合并改动之前，你可以使用如下命令预览差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>为软件发布创建标签是推荐的。这个概念早已存在，在SVN中也有。可以执行如下命令创建一个叫做 1.0.0 的标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 1.0.0 1b2e1d63ff</span><br></pre></td></tr></table></figure><p>1b2e1d63ff 是你想要标记的提交ID的前10位字符。可以使用下列命令获取提交 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>你也可以少写一点提交ID前几位，只要它的指向具有唯一性。</p><h2 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h2><p>假如你操作失误，可以使用如下命令替换掉本地改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>内建的图形化 git：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure><p>彩色的 git 输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>显示历史记录时，每个提交的信息只显示一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config format.pretty oneline</span><br></pre></td></tr></table></figure><p>交互式添加文件到暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单的git操作指南&lt;/p&gt;
&lt;h2 id=&quot;安装git&quot;&gt;&lt;a href=&quot;#安装git&quot; class=&quot;headerlink&quot; title=&quot;安装git&quot;&gt;&lt;/a&gt;安装git&lt;/h2&gt;&lt;p&gt;git支持多操作系统，包括macos，windows，linux&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>软件测试必备：常用sql语句</title>
    <link href="http://example.com/2021/12/21/%E6%B5%8B%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B8%B8%E7%94%A8sql%E8%AF%AD%E5%8F%A5/"/>
    <id>http://example.com/2021/12/21/%E6%B5%8B%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B8%B8%E7%94%A8sql%E8%AF%AD%E5%8F%A5/</id>
    <published>2021-12-20T17:08:39.000Z</published>
    <updated>2021-12-22T17:11:58.208Z</updated>
    
    <content type="html"><![CDATA[<p>总结的基础sql语句，不完全适用于mysql，软件测试必备技能，需要熟记熟用<br>（持续补充）</p><h2 id="Table-表管理"><a href="#Table-表管理" class="headerlink" title="Table 表管理"></a>Table 表管理</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>创建一个名为student的表没包含id，name和age三个字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (id INT PRIMARY KEY, name VARCHAR(20) NOT NUll,age INT DEFAULT 0);</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE student;</span><br></pre></td></tr></table></figure><h3 id="新增列"><a href="#新增列" class="headerlink" title="新增列"></a>新增列</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">ADD col_name col_type;</span><br></pre></td></tr></table></figure><h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">DROP COLUMN col_1;</span><br></pre></td></tr></table></figure><h3 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">ADD constraint;</span><br></pre></td></tr></table></figure><h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">DROP constraint;</span><br></pre></td></tr></table></figure><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE current_name</span><br><span class="line">RENAME TO new_name;</span><br></pre></td></tr></table></figure><h3 id="重命名列"><a href="#重命名列" class="headerlink" title="重命名列"></a>重命名列</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">CHANGE COLUMN old_col new_col data_type;</span><br></pre></td></tr></table></figure><h3 id="清空表数据（截断表）"><a href="#清空表数据（截断表）" class="headerlink" title="清空表数据（截断表）"></a>清空表数据（截断表）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE student;</span><br></pre></td></tr></table></figure><h2 id="Delete-删除"><a href="#Delete-删除" class="headerlink" title="Delete 删除"></a>Delete 删除</h2><h3 id="删除表中所有行（清空表记录）"><a href="#删除表中所有行（清空表记录）" class="headerlink" title="删除表中所有行（清空表记录）"></a>删除表中所有行（清空表记录）</h3><p>attention：TRUNCATE清空表会恢复自增长字段初始值，而DELETE清空不会</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM student;</span><br></pre></td></tr></table></figure><h3 id="删除student表中满足查询条件的行"><a href="#删除student表中满足查询条件的行" class="headerlink" title="删除student表中满足查询条件的行"></a>删除student表中满足查询条件的行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM student WHERE id = <span class="string">&quot;001&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="Insert-新增"><a href="#Insert-新增" class="headerlink" title="Insert 新增"></a>Insert 新增</h2><h3 id="在表中插入一条记录，对所有字段赋值"><a href="#在表中插入一条记录，对所有字段赋值" class="headerlink" title="在表中插入一条记录，对所有字段赋值"></a>在表中插入一条记录，对所有字段赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO student VALUES (001,<span class="string">&quot;alice&quot;</span>,20);</span><br></pre></td></tr></table></figure><h3 id="在表中插入数据，对指定字段赋值"><a href="#在表中插入数据，对指定字段赋值" class="headerlink" title="在表中插入数据，对指定字段赋值"></a>在表中插入数据，对指定字段赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO student (id,name,age) VALUES (002,<span class="string">&quot;apple&quot;</span>,23);</span><br></pre></td></tr></table></figure><h3 id="插入多行数据"><a href="#插入多行数据" class="headerlink" title="插入多行数据"></a>插入多行数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO student (id,name,age) VALUES (003,<span class="string">&quot;Aldous&quot;</span>,30),(004,<span class="string">&quot;Arthur&quot;</span>,30),...;</span><br></pre></td></tr></table></figure><h3 id="INSERT…SELECT-插入"><a href="#INSERT…SELECT-插入" class="headerlink" title="INSERT…SELECT 插入"></a>INSERT…SELECT 插入</h3><p>将student中查询的数据插入到user表中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t_user_info(id,name) SELECT id,name from student;</span><br></pre></td></tr></table></figure><h2 id="Update-修改"><a href="#Update-修改" class="headerlink" title="Update 修改"></a>Update 修改</h2><h3 id="修改所有行的单个列的值"><a href="#修改所有行的单个列的值" class="headerlink" title="修改所有行的单个列的值"></a>修改所有行的单个列的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student SET update_time = <span class="string">&quot;2021-12-12&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="根据条件修改对应的指定列的值"><a href="#根据条件修改对应的指定列的值" class="headerlink" title="根据条件修改对应的指定列的值"></a>根据条件修改对应的指定列的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student SET name = <span class="string">&quot;alice001&quot;</span> <span class="built_in">where</span> id = <span class="string">&quot;001&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="关联更新"><a href="#关联更新" class="headerlink" title="关联更新"></a>关联更新</h3><p>在更新sql语句中可以使用连接查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student s JOIN t_user_info u ON s.uid = u.id</span><br><span class="line">SET s.col_1 = 1 <span class="built_in">where</span> s.col_1 = 0 AND u.col_2 IS NULL;</span><br></pre></td></tr></table></figure><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="单表查询多列"><a href="#单表查询多列" class="headerlink" title="单表查询多列"></a>单表查询多列</h3><p>从table_name获取col_1,col_2,col_3列数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_1,col_2,col_3 FROM table_name;</span><br></pre></td></tr></table></figure><h3 id="查询表中所有列数据"><a href="#查询表中所有列数据" class="headerlink" title="查询表中所有列数据"></a>查询表中所有列数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from table_name;</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>根据过滤条件从table_name表中获取col_1,col_2列的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_1,col_2 </span><br><span class="line">FROM table_name </span><br><span class="line">WHERE id = <span class="string">&quot;001&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><h3 id="DISTINCT-去重"><a href="#DISTINCT-去重" class="headerlink" title="DISTINCT 去重"></a>DISTINCT 去重</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(col_1)</span><br><span class="line">from table_name</span><br><span class="line"><span class="built_in">where</span> <span class="built_in">type</span> = <span class="string">&quot;int&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="ORDER-BY-生序-降序排序"><a href="#ORDER-BY-生序-降序排序" class="headerlink" title="ORDER BY 生序/降序排序"></a>ORDER BY 生序/降序排序</h3><p>ASC–生序<br>DESC–降序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from table_name ORDER BY col_1 ASC;</span><br><span class="line"></span><br><span class="line">SELECT * form table_name ORDER BY col_1 DESC;</span><br></pre></td></tr></table></figure><h3 id="LIMIT-n-OFFSER-m-分页查询"><a href="#LIMIT-n-OFFSER-m-分页查询" class="headerlink" title="LIMIT n OFFSER m 分页查询"></a>LIMIT n OFFSER m 分页查询</h3><p>从表table_name中以col_2降序排序，去掉两行数据，获取第一个(即结果数据中第行数据)col_1,col2的值，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_1,col_2 FROM table_name ORDER BY col_2 DESC LIMIT 1 OFFSET 2;</span><br></pre></td></tr></table></figure><h3 id="ORDER-BY-分组"><a href="#ORDER-BY-分组" class="headerlink" title="ORDER BY 分组"></a>ORDER BY 分组</h3><p>分组常采用聚合函数进行计算，如SUM，AVG，COUNT，MAX，MIN</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_1,SUM(col_2) FROM table_name GROUP BY col_1;</span><br></pre></td></tr></table></figure><h3 id="HAVING-分组过滤"><a href="#HAVING-分组过滤" class="headerlink" title="HAVING 分组过滤"></a>HAVING 分组过滤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_1,SUM(col_2) FROM table_name GROUP BY col_1 HAVING <span class="built_in">type</span> IS NULL;</span><br></pre></td></tr></table></figure><h2 id="高级查询-常见sql操作符"><a href="#高级查询-常见sql操作符" class="headerlink" title="高级查询 常见sql操作符"></a>高级查询 常见sql操作符</h2><h3 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h3><p>合并两个查询结果集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_1,col_2 FROM table1 UNION [ALL] SELECT col_1,col_2 FROM table2;</span><br></pre></td></tr></table></figure><h3 id="LIKE-NOT-LIKE"><a href="#LIKE-NOT-LIKE" class="headerlink" title="LIKE/NOT LIKE"></a>LIKE/NOT LIKE</h3><p>根据给定模式进行匹配（模糊查询）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_1,col_2 FROM table_name WHERE col_1 LIKE pattern;</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">SELECT col_1,col_2 FROM table_name WHERE col_1 NOT LIKE pattern;</span><br></pre></td></tr></table></figure><h3 id="IN-NOT-IN"><a href="#IN-NOT-IN" class="headerlink" title="IN/NOT IN"></a>IN/NOT IN</h3><p>根据给定数据集，获取指定列具有/不具有响应列的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_1,col_2 FROM table_name WHERE col_1 IN (<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">SELECT col_1,col_2 FROM table_name WHERE col_1 NOT IN (<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="BETWEEN…AND…"><a href="#BETWEEN…AND…" class="headerlink" title="BETWEEN…AND…"></a>BETWEEN…AND…</h3><p>获取列表在给定范围内的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE col_1 BETWEEN <span class="string">&quot;10&quot;</span> and <span class="string">&quot;50&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="NULL-NOT-NULL"><a href="#NULL-NOT-NULL" class="headerlink" title="NULL/NOT NULL"></a>NULL/NOT NULL</h3><p>获取列值为空或非空的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE col_1 IS NULL;</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">SELECT * FROM table_name WHERE col_1 IS NOT NULL;</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="INNER-JOIN-内连接"><a href="#INNER-JOIN-内连接" class="headerlink" title="INNER JOIN 内连接"></a>INNER JOIN 内连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A INNER JOIN B ON A.key = B.key; </span><br></pre></td></tr></table></figure><h3 id="LEFT-JOIN-左外连接"><a href="#LEFT-JOIN-左外连接" class="headerlink" title="LEFT JOIN 左外连接"></a>LEFT JOIN 左外连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A LEFT JOIN B ON A.key = B.key;</span><br></pre></td></tr></table></figure><h3 id="LEFT-JOIN-左外连接（排除B部分）"><a href="#LEFT-JOIN-左外连接（排除B部分）" class="headerlink" title="LEFT JOIN 左外连接（排除B部分）"></a>LEFT JOIN 左外连接（排除B部分）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A LEFT JOIN B ON A.key = B.key WHERE B.key IS NULL;</span><br></pre></td></tr></table></figure><h3 id="RIGHT-JOIN-右外连接"><a href="#RIGHT-JOIN-右外连接" class="headerlink" title="RIGHT JOIN 右外连接"></a>RIGHT JOIN 右外连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A RIGHT JOIN B ON A.key = B.key;</span><br></pre></td></tr></table></figure><h3 id="RIGHT-JOIN-右外连接（排除A部分）"><a href="#RIGHT-JOIN-右外连接（排除A部分）" class="headerlink" title="RIGHT JOIN 右外连接（排除A部分）"></a>RIGHT JOIN 右外连接（排除A部分）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A RIGHT JOIN B ON A.key = B.key WHERE A.key IS NULL;</span><br></pre></td></tr></table></figure><h3 id="FULL-JOIN-全外连接"><a href="#FULL-JOIN-全外连接" class="headerlink" title="FULL JOIN 全外连接"></a>FULL JOIN 全外连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A FULL JOIN B ON A.key = B.key;</span><br></pre></td></tr></table></figure><p>attention:MYSQL中不支持FULL JOIN，可以使用UNION ALL的方式达到FULL JOIN效果</p><h3 id="FULL-JOIN-全外连接（排除交叉）"><a href="#FULL-JOIN-全外连接（排除交叉）" class="headerlink" title="FULL JOIN 全外连接（排除交叉）"></a>FULL JOIN 全外连接（排除交叉）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A FULL JOIN B ON A.key = B.key WHERE A.key IS NULL</span><br><span class="line">OR B.key IS NULL;</span><br></pre></td></tr></table></figure><p>attention:MYSQL中不支持FULL JOIN，可以使用UNION ALL的方式达到FULL JOIN效果</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="独立于外部查询，子查询只执行一次，执行完将结果传递给外部查询"><a href="#独立于外部查询，子查询只执行一次，执行完将结果传递给外部查询" class="headerlink" title="独立于外部查询，子查询只执行一次，执行完将结果传递给外部查询"></a>独立于外部查询，子查询只执行一次，执行完将结果传递给外部查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A WHERE A.id IN(SELECT id FORM B);</span><br></pre></td></tr></table></figure><h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>依赖于外部查询的数据，外部查询每执行一次，子查询就执行一次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM grade t1 WHERE t1.score &gt;</span><br><span class="line">(SELECT AVG(t2.score) FROM grade t2 WHERE t1.id = t2.id);</span><br></pre></td></tr></table></figure><h3 id="比较运算符子查询"><a href="#比较运算符子查询" class="headerlink" title="比较运算符子查询"></a>比较运算符子查询</h3><p>使用比较运算符的子查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id = (SELECT MAX(id)</span><br><span class="line">FROM student);</span><br></pre></td></tr></table></figure><h3 id="IN-NOT-IN型子查询"><a href="#IN-NOT-IN型子查询" class="headerlink" title="IN/NOT IN型子查询"></a>IN/NOT IN型子查询</h3><p>data_list可以是具体的数值，也可以是通过子查询得到的数据集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id IN (data_list);</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">SELECT * FROM student WHERE id NOT IN (data_list);</span><br></pre></td></tr></table></figure><h3 id="EXISTS-NOT-EXISTS型子查询"><a href="#EXISTS-NOT-EXISTS型子查询" class="headerlink" title="EXISTS/NOT EXISTS型子查询"></a>EXISTS/NOT EXISTS型子查询</h3><p>exists对外表进行循环逐条查询，每次查询会查看exists的条件语句，如果子查询返回记录行，则留下当前循环的这条记录，否则丢弃这记录。not exists则相反</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE EXISTS (select id FROM B);</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE NOT EXISTS (select id FROM B);</span><br></pre></td></tr></table></figure><h2 id="LIMIT-分页查询"><a href="#LIMIT-分页查询" class="headerlink" title="LIMIT 分页查询"></a>LIMIT 分页查询</h2><h3 id="LIMIT-M-N分页"><a href="#LIMIT-M-N分页" class="headerlink" title="LIMIT M,N分页"></a>LIMIT M,N分页</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student LIMIT 0,10;</span><br><span class="line"></span><br><span class="line">SELECT * FROM student LIMIT 10,10;</span><br></pre></td></tr></table></figure><h3 id="LIMIT-M-OFFSET-N-分页"><a href="#LIMIT-M-OFFSET-N-分页" class="headerlink" title="LIMIT M OFFSET N 分页"></a>LIMIT M OFFSET N 分页</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student LIMIT 10 OFFSET 0;</span><br><span class="line"></span><br><span class="line">SELECT * FROM student LIMIT 10 OFFSET 10;</span><br></pre></td></tr></table></figure><h3 id="TOP语法-取前几条记录"><a href="#TOP语法-取前几条记录" class="headerlink" title="TOP语法 取前几条记录"></a>TOP语法 取前几条记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student LIMIT 5;</span><br><span class="line"></span><br><span class="line">SELECT * FROM student ORDER BY id DESC LIMIT 1;</span><br></pre></td></tr></table></figure><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><h3 id="AVG-求平均值"><a href="#AVG-求平均值" class="headerlink" title="AVG()求平均值"></a>AVG()求平均值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(age) FROM student;</span><br></pre></td></tr></table></figure><h3 id="COUNT-统计行数"><a href="#COUNT-统计行数" class="headerlink" title="COUNT()统计行数"></a>COUNT()统计行数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(id) FROM student; </span><br></pre></td></tr></table></figure><h3 id="MAX-求最大值"><a href="#MAX-求最大值" class="headerlink" title="MAX()求最大值"></a>MAX()求最大值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(age) FROM student;</span><br></pre></td></tr></table></figure><h3 id="MIN-求最小值"><a href="#MIN-求最小值" class="headerlink" title="MIN()求最小值"></a>MIN()求最小值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MIN(age) FROM student;</span><br></pre></td></tr></table></figure><h3 id="SUM-求和"><a href="#SUM-求和" class="headerlink" title="SUM()求和"></a>SUM()求和</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(age) FROM student;</span><br></pre></td></tr></table></figure><h3 id="GROUP-CONCAT"><a href="#GROUP-CONCAT" class="headerlink" title="GROUP_CONCAT()"></a>GROUP_CONCAT()</h3><p>将GROUP BY产生的同一分组中的值连接起来，返回一个字符串结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,GROUP_CONCAT(id) FROM student GROUP BY name;</span><br></pre></td></tr></table></figure><h2 id="VIEW-视图"><a href="#VIEW-视图" class="headerlink" title="VIEW 视图"></a>VIEW 视图</h2><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>创建table的col_1和col_2两列的视图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW view_1(col_1,col_2) AS SELECT col_1,col_2 FROM table1;</span><br></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW view_1；</span><br></pre></td></tr></table></figure><h2 id="INDEX-索引"><a href="#INDEX-索引" class="headerlink" title="INDEX 索引"></a>INDEX 索引</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>在table1的col_1和col_2上创建一个索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_1 ON table_1(col_1,col_2);</span><br></pre></td></tr></table></figure><h3 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_1 ON table1(col_1,col_2);</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_1 ON table1;</span><br></pre></td></tr></table></figure><h2 id="TRIGGER-触发器"><a href="#TRIGGER-触发器" class="headerlink" title="TRIGGER 触发器"></a>TRIGGER 触发器</h2><h3 id="创建触发器语法"><a href="#创建触发器语法" class="headerlink" title="创建触发器语法"></a>创建触发器语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON table_name FOR EACH ROW trigger_stmt;</span><br></pre></td></tr></table></figure><p>trigger_name:触发器名称<br>trigger_time:触发程序动作时间，表示出发程序是在激活它的语句之前或之后出发，可以是BEFORE或AFTER<br>trigger_event:激活触发的语句类型，可以是INSERT、UPDATE、DELETE<br>table_name:表名，必须是永久表，不能是缓存表<br>trigger_stmt:触发激活时执行的语句</p><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER trigger_name;</span><br></pre></td></tr></table></figure><h2 id="控制流程函数"><a href="#控制流程函数" class="headerlink" title="控制流程函数"></a>控制流程函数</h2><h3 id="IFNULL-判空表达式"><a href="#IFNULL-判空表达式" class="headerlink" title="IFNULL 判空表达式"></a>IFNULL 判空表达式</h3><p>语法：IFNULL(expr1,expr2)<br>expr1不为NULL，则IFNULL()的返回值为expr1；否则其返回值为expr2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT id IFNULL(class_id,0) FROM student;</span><br><span class="line"></span><br><span class="line">SELECT IFNULL(1,0);</span><br><span class="line"><span class="comment">#--1</span></span><br><span class="line">SELECT IFNULL(NULL,10);</span><br><span class="line"><span class="comment">#--10</span></span><br></pre></td></tr></table></figure><h3 id="NULLIF"><a href="#NULLIF" class="headerlink" title="NULLIF"></a>NULLIF</h3><p>语法：NULLIF（expr1,expr2),假如expr1 = expr2,返回null，否则返回expr1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT NULLIF(1,1);</span><br><span class="line"><span class="comment">#--NULL</span></span><br><span class="line">SELECT NULLIF(1,2);</span><br><span class="line"><span class="comment">#--1</span></span><br></pre></td></tr></table></figure><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><p>语法：IF(expr1,expr2,expr3)<br>expr1是TRUE(expr1&lt;&gt;0 and expr1&lt;&gt;NULL).则IF()的返回值为expr2；否则返回值为expr3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT IF(1&lt;2,<span class="string">&#x27;yes&#x27;</span>,<span class="string">&#x27;no&#x27;</span>);</span><br><span class="line"><span class="comment">#---yes</span></span><br></pre></td></tr></table></figure><h3 id="CASE…WHEN…THEN…"><a href="#CASE…WHEN…THEN…" class="headerlink" title="CASE…WHEN…THEN…"></a>CASE…WHEN…THEN…</h3><p>用于计算条件列表并返回多个可能结果表达式之一，类似于程序语言的条件分支语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CASE sex WHEN <span class="string">&#x27;1&#x27;</span> THEN <span class="string">&#x27;男&#x27;</span> WHEN <span class="string">&#x27;2&#x27;</span> THEN <span class="string">&#x27;女&#x27;</span> ELSE ‘其他’ END FROM student；</span><br></pre></td></tr></table></figure><h2 id="PROCEDURE-存储过程"><a href="#PROCEDURE-存储过程" class="headerlink" title="PROCEDURE 存储过程"></a>PROCEDURE 存储过程</h2><p>概念：<br>存储过程是大型数据库系统非常重要的对象，它是一组为了完成特定功能的SQL语句集，是SQL语句和控制语句的预编译合集</p><p>不带参数的存储过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE proc_show_curdate() </span><br><span class="line">BEGIN </span><br><span class="line">select CURDATE();</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>带IN和OUT类型参数的存储过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE proc_del_and_count (IN del_id INT UNSIGNED,OUT count_records INT UNSIGNED)</span><br><span class="line">BEGIM</span><br><span class="line">DELETE FROM student WHERE id=del_id;</span><br><span class="line">SELECT COUNT(1) FROM student INTO count_records;</span><br><span class="line">END </span><br></pre></td></tr></table></figure><p>调用存储过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL proc_show_curdate();</span><br><span class="line"></span><br><span class="line">CALL proc_del_and_count(1.@count_records);</span><br></pre></td></tr></table></figure><p>获得用户变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @count_records；</span><br></pre></td></tr></table></figure><p>删除存储过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE proc_del_and_count;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结的基础sql语句，不完全适用于mysql，软件测试必备技能，需要熟记熟用&lt;br&gt;（持续补充）&lt;/p&gt;
&lt;h2 id=&quot;Table-表管理&quot;&gt;&lt;a href=&quot;#Table-表管理&quot; class=&quot;headerlink&quot; title=&quot;Table 表管理&quot;&gt;&lt;/a&gt;Tab</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/12/19/hello-world/"/>
    <id>http://example.com/2021/12/19/hello-world/</id>
    <published>2021-12-19T13:58:14.287Z</published>
    <updated>2021-12-19T13:58:14.287Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Python基础语法</title>
    <link href="http://example.com/2021/12/16/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2021/12/16/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2021-12-15T17:22:20.000Z</published>
    <updated>2023-03-14T18:17:23.786Z</updated>
    
    <content type="html"><![CDATA[<p>总结的python基础语法，必须熟记和使用<br>(持续完善)</p><span id="more"></span><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是赋给值的标签；<br>变量是指向特定值</p><h3 id="变量的使用和命名"><a href="#变量的使用和命名" class="headerlink" title="变量的使用和命名"></a>变量的使用和命名</h3><ol><li>变量只能包含字母，数字，下划线（_）：能以字母or下划线打头，但不可用数字打头</li><li>变量名不可包含空格</li><li>不要将python关键字与函数名用作变量名</li><li>变量名应既简单又具有描述性</li><li>慎用小写字母l和大写字母O，很容易看成1和0</li></ol><h2 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h2><p>赋值使用‘ ’or“ ”圈住内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello world python&#x27;</span></span><br></pre></td></tr></table></figure><p>打印字符串s的第一个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(s[0])</span><br></pre></td></tr></table></figure><p>打印字符串s倒数第6个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(s[-6])</span><br></pre></td></tr></table></figure><p>字符串的切片:取字符串s第1至第12个字符，每两个输出一个字符，()内区间，左闭右开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(s[0:12:2])</span><br></pre></td></tr></table></figure><p>attention:input()输出的数据类型默认为字符串</p><h3 id="字符串的格式化输出1"><a href="#字符串的格式化输出1" class="headerlink" title="字符串的格式化输出1:"></a>字符串的格式化输出1:</h3><p>%s:字符串 —接受任何数据类型<br>%d:整数   —仅支持数字<br>%f:浮点数 —仅支持数字<br>%的作用是占坑，( )做格式化输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;=====个人信息=====</span></span><br><span class="line"><span class="string">    姓名：%s</span></span><br><span class="line"><span class="string">    性别：%s</span></span><br><span class="line"><span class="string">    年龄：%d</span></span><br><span class="line"><span class="string">    身高：%f</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span>%(<span class="string">&#x27;小七&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,18,160.5)</span><br><span class="line">)</span><br><span class="line">=====个人信息=====</span><br><span class="line">    姓名：小七</span><br><span class="line">    性别：女</span><br><span class="line">    年龄：18</span><br><span class="line">    身高：160.500000</span><br></pre></td></tr></table></figure><h3 id="字符串的格式化输出2-format-有序和无序"><a href="#字符串的格式化输出2-format-有序和无序" class="headerlink" title="字符串的格式化输出2:.format 有序和无序"></a>字符串的格式化输出2:.format 有序和无序</h3><p>{}占坑,字符串.format—–&gt;相对来说使用的比较频繁，例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">=====个人信息=====</span></span><br><span class="line"><span class="string">姓名：&#123;&#125;</span></span><br><span class="line"><span class="string">性别：&#123;&#125;</span></span><br><span class="line"><span class="string">年龄：&#123;&#125;</span></span><br><span class="line"><span class="string">身高：&#123;&#125;</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span>.format(<span class="string">&#x27;七仔&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,20,165.3)</span><br><span class="line">      )</span><br><span class="line">=====个人信息=====</span><br><span class="line">姓名：七仔</span><br><span class="line">性别：女</span><br><span class="line">年龄：20</span><br><span class="line">身高：165.3</span><br></pre></td></tr></table></figure><p>attention:<br>1.{}跟数据的个数最好一致，如果不一致起码{}要比值的数量少；<br>2.()里面的值也是有索引的，也是从0开始，我们可以在{}指定取值的索引<br>3.可以在有些{}给定索引，有些{}不给定索引—-&gt;绝对不行！！！要给就全部给，不给就全部都不给</p><h3 id="python字符串的常用方法"><a href="#python字符串的常用方法" class="headerlink" title="python字符串的常用方法"></a>python字符串的常用方法</h3><p>find()函数：返回-1表示未找到子字符串，如果找到了就返回对应字符的 索引或字符串第一个字符的索引<br>子字符串包含了单个字符，或者是多个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;learn python in lemon&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;n&#x27;</span>))<span class="comment">#返回找到的字符串的索引值&gt;&gt;&gt;4</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;python&#x27;</span>))<span class="comment">#返回找到的字符串的第一个索引值&gt;&gt;&gt;6</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;k&#x27;</span>))<span class="comment">#如果没找到，返回-1&gt;&gt;&gt;-1</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;o&#x27;</span>,1))<span class="comment">#寻找的目标子字符串：一个字符串中存在多个相同的字符，此处寻找第一个o</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;o&#x27;</span>,11))<span class="comment">#寻找的目标子字符串：此处寻找第二个o</span></span><br></pre></td></tr></table></figure><p>isdigit()函数：如果只包含数字，就返回True，否则返回False</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;111&#x27;</span>.isdigit())<span class="comment">#&gt;&gt;&gt;True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s&#x27;</span>.isdigit())<span class="comment">#&gt;&gt;&gt;False</span></span><br></pre></td></tr></table></figure><p>replace（）函数：指定替换内容以及被替换字符串，并且可以指定替换次数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s[0] = <span class="string">&#x27;k&#x27;</span> </span><br><span class="line"><span class="comment">#TypeError:&#x27;str&#x27;,object does not support item assignment 不能根据索引重新指派</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[0])<span class="comment">#&gt;&gt;&gt;l</span></span><br><span class="line">new_s = s.replace(<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_s)<span class="comment">#&gt;&gt;&gt;leark pythok ik lemok</span></span><br><span class="line">renew_s = s.replace(<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,1)<span class="comment">#数字表示替换的次数，当需要替换的字符串有多个，不填写数字则默认全部替换，填写数字则进行对应次数替换</span></span><br><span class="line"><span class="built_in">print</span>(renew_s)<span class="comment">#&gt;&gt;&gt;leark python in lemon</span></span><br></pre></td></tr></table></figure><p>split()函数：根据指定字符对字符串进行切割,可以指定切割的次数，默认是全部切割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="string">&#x27;learn python in lemon&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(t.split(<span class="string">&#x27; &#x27;</span>,2)) <span class="comment">#返回一个列表，列表里面的元素都是字符串,attention:这里指定空格为切割符；结果：[&#x27;learn&#x27;, &#x27;python&#x27;, &#x27;in lemon&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(t.split(<span class="string">&#x27;l&#x27;</span>))<span class="comment">#结果：[&#x27;&#x27;, &#x27;earn python in &#x27;, &#x27;emon&#x27;]，这里被用作切割符的字符串结果中不展示，第一个返回是个空字符串</span></span><br></pre></td></tr></table></figure><p>strip()函数：去掉头或尾指定的字符，返回一个新的字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;****learn python in lemon\n&#x27;</span><span class="comment">#\n-python中的换行符</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a_2 = a.strip(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a_2)<span class="comment">#&gt;&gt;&gt;learn python in lemon\n</span></span><br><span class="line">a_3 = a_2.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a_3)<span class="comment">#&gt;&gt;&gt;learn python in lemon</span></span><br></pre></td></tr></table></figure><p>upper()函数：字符串字母转成大写<br>lower()函数：字符串的字母转成小写<br>swapcase()函数：字符串的字母大小写互换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="string">&#x27;learn python in lemon&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b.upper())<span class="comment">#&gt;&gt;&gt;LEARN PYTHON IN LEMON</span></span><br><span class="line"><span class="built_in">print</span>(b.upper().lower())<span class="comment">#&gt;&gt;&gt;learn python in lemon</span></span><br><span class="line">常用于不区分大小写限制</span><br><span class="line"><span class="built_in">print</span>(b.swapcase())<span class="comment">#&gt;&gt;&gt;LEARN PYTHON IN LEMON</span></span><br></pre></td></tr></table></figure><h2 id="数据类型-列表-list"><a href="#数据类型-列表-list" class="headerlink" title="数据类型_列表_list"></a>数据类型_列表_list</h2><p>python的数据类型之列表<br>列表的定义：<br>关键字：list（列表）<br>使用最频繁的数据类型，列表可以完成大多数集合类的数据结构实现<br>它支持字符，数字，字符串甚至包含列表（即嵌套）<br>列表用[]标识<br>有序数据</p><h3 id="1-空列表"><a href="#1-空列表" class="headerlink" title="1.空列表"></a>1.空列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t))<span class="comment">#&gt;&gt;&gt;&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(len(t))<span class="comment">#&gt;&gt;&gt;0</span></span><br></pre></td></tr></table></figure><h3 id="2-列表里面的数据用逗号隔开，数据可以是任意数据类型"><a href="#2-列表里面的数据用逗号隔开，数据可以是任意数据类型" class="headerlink" title="2.列表里面的数据用逗号隔开，数据可以是任意数据类型"></a>2.列表里面的数据用逗号隔开，数据可以是任意数据类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = [1,0.03,False,True,<span class="string">&#x27;hello&#x27;</span>,(1,2,<span class="string">&#x27;python&#x27;</span>),[1,0.5,False]]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t))<span class="comment">#&gt;&gt;&gt;&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(len(t))<span class="comment">#&gt;&gt;&gt;7</span></span><br><span class="line"><span class="built_in">print</span>(t[2])<span class="comment">#&gt;&gt;&gt;False</span></span><br><span class="line"><span class="built_in">print</span>(t[5][2][2])<span class="comment">#&gt;&gt;&gt;t</span></span><br><span class="line"><span class="built_in">print</span>(t[-1][-1])<span class="comment">#&gt;&gt;&gt;False</span></span><br></pre></td></tr></table></figure><h3 id="3-列表的操作：增删改查"><a href="#3-列表的操作：增删改查" class="headerlink" title="3.列表的操作：增删改查"></a>3.列表的操作：增删改查</h3><p>列表的特性：有序可变<br>有序：说明有索引，索引也是从0/-1开始，也分正序和反序，索引规则同字符串<br>可变：说明列表可以做删 增 改<br>切片：同字符串切片规则，列表明[start:end:step]</p><h4 id="取值偶数位的元素"><a href="#取值偶数位的元素" class="headerlink" title="取值偶数位的元素"></a>取值偶数位的元素</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(t[0::2])<span class="comment">#取到的还是列表&gt;&gt;&gt;[1, False, &#x27;hello&#x27;, [1, 0.5, False]]</span></span><br></pre></td></tr></table></figure><h4 id="列表进行倒叙输出"><a href="#列表进行倒叙输出" class="headerlink" title="列表进行倒叙输出"></a>列表进行倒叙输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(t[::-1])<span class="comment">#&gt;&gt;&gt;[[1, 0.5, False], (1, 2, &#x27;python&#x27;), &#x27;hello&#x27;, True, False, 0.03, 1]</span></span><br></pre></td></tr></table></figure><p>attention：<br>列表与元祖的不同之处<br>1.元祖不可变，列表可变<br>2.元祖如果只有一个元素要记得加逗号，列表无这个操作<br>3.元祖 tuple() 列表 list[]</p><p>列表与元祖的相同之处：<br>1.有序 有索引<br>2.可以根据索引取值<br>3.切片的方法方式都是一样的</p><h4 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t.append(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(t)<span class="comment">#&gt;&gt;&gt;[1, 0.03, False, True, &#x27;hello&#x27;, (1, 2, &#x27;python&#x27;), [1, 0.5, False], &#x27;test&#x27;]</span></span><br><span class="line">t.append(<span class="string">&#x27;测试&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(t)<span class="comment">#&gt;&gt;&gt;[1, 0.03, False, True, &#x27;hello&#x27;, (1, 2, &#x27;python&#x27;), [1, 0.5, False], &#x27;test&#x27;, &#x27;测试&#x27;]</span></span><br></pre></td></tr></table></figure><p>综上所述.append()默认追加元素到列表的末尾，每次只能添加一个元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t.insert(1,<span class="string">&#x27;insert&#x27;</span>)<span class="comment">#可以插入到指定索引位置，原有的保留并往后挪一位&gt;&gt;&gt;[1, &#x27;insert&#x27;, 0.03, False, True, &#x27;hello&#x27;, (1, 2, &#x27;python&#x27;), [1, 0.5, False], &#x27;test&#x27;, &#x27;测试&#x27;]</span></span><br><span class="line">t.extend([1,2,3,4])<span class="comment">#拓展列表的操作，合并列表，注意是合并而不是将列表作为一个值嵌套进列表中&gt;&gt;&gt;[1, &#x27;insert&#x27;, 0.03, False, True, &#x27;hello&#x27;, (1, 2, &#x27;python&#x27;), [1, 0.5, False], &#x27;test&#x27;, &#x27;测试&#x27;, 1, 2, 3, 4]</span></span><br><span class="line">s = [5,6,7]</span><br><span class="line">t = t+s</span><br><span class="line"><span class="built_in">print</span>(t)<span class="comment">#&gt;&gt;&gt;[1, &#x27;insert&#x27;, 0.03, False, True, &#x27;hello&#x27;, (1, 2, &#x27;python&#x27;), [1, 0.5, False], &#x27;test&#x27;, &#x27;测试&#x27;, 1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t.pop()<span class="comment">#默认删除最后一个元素</span></span><br><span class="line">t.pop(i)<span class="comment">#删除列表中指定位置的元素</span></span><br><span class="line">t.pop(0)<span class="comment">#删除列表中第一个值</span></span><br><span class="line">t.clear()<span class="comment">#移除列表里面的所有数据</span></span><br></pre></td></tr></table></figure><h4 id="修改元素，修改原有的值，赋值的方式-列表名-索引值-新值"><a href="#修改元素，修改原有的值，赋值的方式-列表名-索引值-新值" class="headerlink" title="修改元素，修改原有的值，赋值的方式 列表名[索引值]=新值"></a>修改元素，修改原有的值，赋值的方式 列表名[索引值]=新值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t2[2] = False</span><br><span class="line"><span class="built_in">print</span>(t2)<span class="comment">#&gt;&gt;&gt;[1, 0.02, False, &#x27;hello&#x27;, (1, 2, 3, &#x27;python&#x27;), [1, 0.02, False, [&#x27;hello&#x27;]]]</span></span><br></pre></td></tr></table></figure><h4 id="查：根据索引值取值，切片"><a href="#查：根据索引值取值，切片" class="headerlink" title="查：根据索引值取值，切片"></a>查：根据索引值取值，切片</h4><p>.index()<br>.count()</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(t2.index(1))<span class="comment">#括号内的值为列表中的元素，作用是确定元素所在的搜索位置&gt;&gt;&gt;0</span></span><br><span class="line"><span class="built_in">print</span>(t2.count(0.02))<span class="comment">#统计列表中0.02这个元素的数量&gt;&gt;&gt;1</span></span><br></pre></td></tr></table></figure><p>百分百需要记住的函数：.append();.extend();insert()；.pop();</p><h2 id="数据类型-元祖-tuple"><a href="#数据类型-元祖-tuple" class="headerlink" title="数据类型_元祖_tuple"></a>数据类型_元祖_tuple</h2><p>元祖的定义：<br>特性：关键字 tuple()<br>它支持字符，数字，字符串甚至可以包含元祖（即嵌套）<br>元祖用（）标识<br>有序数据<br>t = ()#空元祖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t))<span class="comment">#&gt;&gt;&gt;&lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(len)<span class="comment">#&gt;&gt;&gt;0</span></span><br></pre></td></tr></table></figure><p>t2 = (1,)#只有一个数据的时候注意取法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t2))<span class="comment">#&gt;&gt;&gt;&lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(t2)<span class="comment">#&gt;&gt;&gt;0</span></span><br></pre></td></tr></table></figure><h3 id="索引，索引取值，切片同字符串的方法"><a href="#索引，索引取值，切片同字符串的方法" class="headerlink" title="索引，索引取值，切片同字符串的方法"></a>索引，索引取值，切片同字符串的方法</h3><p>修改元祖的值：不可修改，元祖属于不可变数据<br>嵌套元祖，例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t3 = (1,0.03,True,<span class="string">&#x27;false&#x27;</span>,(4,5,6,<span class="string">&#x27;python&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t3))<span class="comment">#&gt;&gt;&gt;&lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(len(t3))<span class="comment">#&gt;&gt;&gt;5</span></span><br></pre></td></tr></table></figure><h3 id="元祖的特性：有序不可变"><a href="#元祖的特性：有序不可变" class="headerlink" title="元祖的特性：有序不可变"></a>元祖的特性：有序不可变</h3><p>有序：说明有索引，索引也是从0/-1开始，也分正序和反序<br>不可变：说明元祖一旦确定，那么值就不能做变更；删 增 改都不支持</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(t3[0])<span class="comment">#&gt;&gt;&gt;1</span></span><br><span class="line"><span class="built_in">print</span>(t3[-1])<span class="comment">#&gt;&gt;&gt;(4, 5, 6, &#x27;python&#x27;)</span></span><br></pre></td></tr></table></figure><p>元祖里面的嵌套取值：根据索引一层一层的去定位</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(t3[-1][-1][0])<span class="comment">#&gt;&gt;&gt;p</span></span><br></pre></td></tr></table></figure><h3 id="元祖的切片：元祖名-start-end-step"><a href="#元祖的切片：元祖名-start-end-step" class="headerlink" title="元祖的切片：元祖名[start:end:step]"></a>元祖的切片：元祖名[start:end:step]</h3><p>取值偶数位的元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(t3[0::2])<span class="comment">#取到的还是元祖&gt;&gt;&gt;(1, True, (4, 5, 6, &#x27;python&#x27;))</span></span><br></pre></td></tr></table></figure><h3 id="元祖进行倒叙输出"><a href="#元祖进行倒叙输出" class="headerlink" title="元祖进行倒叙输出"></a>元祖进行倒叙输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(t3[::-1])<span class="comment">#&gt;&gt;&gt;((4, 5, 6, &#x27;python&#x27;), &#x27;false&#x27;, True, 0.03, 1)</span></span><br></pre></td></tr></table></figure><h3 id="元祖的常用方法："><a href="#元祖的常用方法：" class="headerlink" title="元祖的常用方法："></a>元祖的常用方法：</h3><p>index(x):获取x的索引值，获取元祖里面某个元素的索引值<br>count(x):统计x的个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(t3.index(0.03))<span class="comment">#&gt;&gt;&gt;1</span></span><br><span class="line"><span class="built_in">print</span>(t3.count(1))<span class="comment">#此处输出为2，why？因为存在布尔值True，布尔值中True == 1；false == 0；</span></span><br></pre></td></tr></table></figure><h2 id="数据类型-字典-dict"><a href="#数据类型-字典-dict" class="headerlink" title="数据类型_字典_dict"></a>数据类型_字典_dict</h2><p>字典的定义：<br>关键字：dictionary（dict），除列表以外python之中最灵活的内置数据结构类型字典是无序的对象集合<br>标识：{}<br>无序数据，是除了列表之外，python中使用最多的数据类型<br>存储数据的形式： key:value<br>key:是唯一的且不可边变的数据（int float tuple boolen，str）<br>value:任何数据类型都支持</p><p>question1：如果key重复的话，会如何？<br>result：后面的值会把前面的值覆盖掉</p><h3 id="空字典"><a href="#空字典" class="headerlink" title="空字典"></a>空字典</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d))<span class="comment">#&gt;&gt;&gt;&lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定义一个字典-key-value"><a href="#定义一个字典-key-value" class="headerlink" title="定义一个字典 key:value"></a>定义一个字典 key:value</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;1:<span class="string">&#x27;no 1&#x27;</span>,</span><br><span class="line">     0.02:<span class="string">&#x27;零花钱&#x27;</span>,</span><br><span class="line">     True:<span class="string">&#x27;result&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;name&#x27;</span>:666,</span><br><span class="line">     (1,3):<span class="string">&#x27;tuple&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;list&#x27;</span>:[2,3,4]</span><br><span class="line">      &#125;</span><br><span class="line"><span class="built_in">print</span>(d1)<span class="comment">#&gt;&gt;&gt;&#123;1: &#x27;result&#x27;, 0.02: &#x27;零花钱&#x27;, &#x27;name&#x27;: 666, (1, 3): &#x27;tuple&#x27;, &#x27;list&#x27;: [2, 3, 4]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="字典的无序"><a href="#字典的无序" class="headerlink" title="字典的无序"></a>字典的无序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(d1)<span class="comment">#每一次执行输出的时候都会变化顺序,随机的不好复现</span></span><br></pre></td></tr></table></figure><h3 id="字典的取值，根据key取值，字典名-key"><a href="#字典的取值，根据key取值，字典名-key" class="headerlink" title="字典的取值，根据key取值，字典名[key]"></a>字典的取值，根据key取值，字典名[key]</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(d1[True])<span class="comment">#&gt;&gt;&gt;result</span></span><br><span class="line"><span class="built_in">print</span>(d1[<span class="string">&#x27;list&#x27;</span>][-1])<span class="comment">#&gt;&gt;&gt;4</span></span><br></pre></td></tr></table></figure><h3 id="key的唯一"><a href="#key的唯一" class="headerlink" title="key的唯一"></a>key的唯一</h3><p>key必须是唯一的不重复的，如果出现重复的，则后面的值会把前面的值覆盖掉<br>字典也是用来存储数据的，那么何时使用字典？<br>当值需要成对存储的时候，可以理解为数据库</p><h3 id="字典的操作，增，删，改，查询"><a href="#字典的操作，增，删，改，查询" class="headerlink" title="字典的操作，增，删，改，查询"></a>字典的操作，增，删，改，查询</h3><h4 id="查：根据key来查询"><a href="#查：根据key来查询" class="headerlink" title="查：根据key来查询"></a>查：根据key来查询</h4><p>字典嵌套字典<br>字典嵌套元祖<br>字典嵌套列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d2=&#123;<span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;python15&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;teacher&#x27;</span>:[<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;小白&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;vip&#x27;</span>:&#123;<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;B&#x27;</span>:<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;c&#x27;</span>:<span class="string">&#x27;小白&#x27;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;score&#x27;</span>:(88,99,100),</span><br><span class="line">    <span class="string">&#x27;test&#x27;</span>:2334,</span><br><span class="line">    <span class="string">&#x27;test02&#x27;</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">取小明的值：方法一层一层的取定位，根据key</span><br><span class="line"><span class="built_in">print</span>(d2[<span class="string">&#x27;vip&#x27;</span>][<span class="string">&#x27;B&#x27;</span>])<span class="comment">#&gt;&gt;&gt;小明</span></span><br><span class="line">取最后一个老师的名字:</span><br><span class="line"><span class="built_in">print</span>(d2[<span class="string">&#x27;teacher&#x27;</span>][-1])<span class="comment">#&gt;&gt;&gt;小白</span></span><br><span class="line">取倒数第二的分数</span><br><span class="line"><span class="built_in">print</span>(d2[<span class="string">&#x27;score&#x27;</span>][-2])<span class="comment">#&gt;&gt;&gt;99</span></span><br></pre></td></tr></table></figure><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[不存在的key] = 新值</span><br></pre></td></tr></table></figure><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d[已有的key] = 新值</span><br><span class="line">d2[<span class="string">&#x27;vip&#x27;</span>][<span class="string">&#x27;A&#x27;</span>] = <span class="string">&#x27;小刚&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d2[<span class="string">&#x27;vip&#x27;</span>][<span class="string">&#x27;A&#x27;</span>])<span class="comment">#&gt;&gt;&gt;小刚</span></span><br><span class="line"><span class="built_in">print</span>(d2)<span class="comment">#&#123;&#x27;class&#x27;: &#x27;python15&#x27;, &#x27;teacher&#x27;: [&#x27;小明&#x27;, &#x27;小红&#x27;, &#x27;小刚&#x27;, &#x27;小白&#x27;], &#x27;vip&#x27;: &#123;&#x27;A&#x27;: &#x27;小刚&#x27;, &#x27;B&#x27;: &#x27;小明&#x27;, &#x27;c&#x27;: &#x27;小白&#x27;&#125;, &#x27;score&#x27;: (88, 99, 100), &#x27;test&#x27;: 2334, &#x27;test02&#x27;: &#x27;hello&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d.pop(<span class="string">&#x27;vip&#x27;</span>)<span class="comment">#根据key删除--删除键值对</span></span><br><span class="line">d.clear()<span class="comment">#清空字典</span></span><br><span class="line">d.popitem()<span class="comment">#随机删除某个键值对</span></span><br></pre></td></tr></table></figure><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><h4 id="items-以列表返回可遍历的（键，值）元组数组"><a href="#items-以列表返回可遍历的（键，值）元组数组" class="headerlink" title="items():以列表返回可遍历的（键，值）元组数组"></a>items():以列表返回可遍历的（键，值）元组数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(d2.items())</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;dict_items([(&#x27;class&#x27;, &#x27;python15&#x27;), (&#x27;teacher&#x27;, [&#x27;小明&#x27;, &#x27;小红&#x27;, &#x27;小刚&#x27;, &#x27;小白&#x27;]), (&#x27;vip&#x27;, &#123;&#x27;A&#x27;: &#x27;小刚&#x27;, &#x27;B&#x27;: &#x27;小明&#x27;, &#x27;c&#x27;: &#x27;小白&#x27;&#125;), (&#x27;score&#x27;, (88, 99, 100)), (&#x27;test&#x27;, 2334), (&#x27;test02&#x27;, &#x27;hello&#x27;)])</span></span><br></pre></td></tr></table></figure><h4 id="keys-以列表返回一个字典所有的键"><a href="#keys-以列表返回一个字典所有的键" class="headerlink" title="keys():以列表返回一个字典所有的键"></a>keys():以列表返回一个字典所有的键</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(d2.keys())</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;dict_keys([&#x27;class&#x27;, &#x27;teacher&#x27;, &#x27;vip&#x27;, &#x27;score&#x27;, &#x27;test&#x27;, &#x27;test02&#x27;])</span></span><br></pre></td></tr></table></figure><h4 id="values-：以列表返回一个字典所有的值"><a href="#values-：以列表返回一个字典所有的值" class="headerlink" title="values()：以列表返回一个字典所有的值"></a>values()：以列表返回一个字典所有的值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(d2.values())</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;dict_values([&#x27;python15&#x27;, [&#x27;小明&#x27;, &#x27;小红&#x27;, &#x27;小刚&#x27;, &#x27;小白&#x27;], &#123;&#x27;A&#x27;: &#x27;小刚&#x27;, &#x27;B&#x27;: &#x27;小明&#x27;, &#x27;c&#x27;: &#x27;小白&#x27;&#125;, (88, 99, 100), 2334, &#x27;hello&#x27;])</span></span><br></pre></td></tr></table></figure><h4 id="pop-key-：删除指定key的字典值，会返回被删除的这个值"><a href="#pop-key-：删除指定key的字典值，会返回被删除的这个值" class="headerlink" title="pop(key)：删除指定key的字典值，会返回被删除的这个值"></a>pop(key)：删除指定key的字典值，会返回被删除的这个值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(d2.pop(<span class="string">&#x27;test02&#x27;</span>))<span class="comment">#&gt;&gt;&gt;hello</span></span><br></pre></td></tr></table></figure><h4 id="del-字典名-key-删除指定key的字典值"><a href="#del-字典名-key-删除指定key的字典值" class="headerlink" title="del 字典名[key]:删除指定key的字典值"></a>del 字典名[key]:删除指定key的字典值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del d2[<span class="string">&#x27;teacher&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(d2)</span><br><span class="line">&gt;&gt;&gt;&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;python15&#x27;</span>, <span class="string">&#x27;vip&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="string">&#x27;小刚&#x27;</span>, <span class="string">&#x27;B&#x27;</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;小白&#x27;</span>&#125;, <span class="string">&#x27;score&#x27;</span>: (88, 99, 100), <span class="string">&#x27;test&#x27;</span>: 2334&#125;</span><br></pre></td></tr></table></figure><h2 id="python运算符"><a href="#python运算符" class="headerlink" title="python运算符"></a>python运算符</h2><p>python语言支持以下类型的运算符：<br>算数运算符–must<br>比较（关系）运算符—must<br>赋值运算符—must<br>逻辑运算符—must<br>成员运算符—must<br>位运算符<br>身份运算符<br>运算符优先级</p><h3 id="算术运算符：-，-，"><a href="#算术运算符：-，-，" class="headerlink" title="算术运算符：+，-，*, /, %"></a>算术运算符：+，-，*, /, %</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 5</span><br><span class="line"><span class="built_in">print</span>(a+b)<span class="comment">#&gt;&gt;&gt;15</span></span><br><span class="line"><span class="built_in">print</span>(a*b)<span class="comment">#&gt;&gt;&gt;50</span></span><br></pre></td></tr></table></figure><h4 id="字符串的拼接，列表的拼接"><a href="#字符串的拼接，列表的拼接" class="headerlink" title="+ 字符串的拼接，列表的拼接"></a>+ 字符串的拼接，列表的拼接</h4><p>乘法：对字符串列表 元组 要输出多次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s_1=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">s_2=[1,2,3]</span><br><span class="line"><span class="built_in">print</span>(s_1*3)<span class="comment">#&gt;&gt;&gt; hellohellohello</span></span><br><span class="line"><span class="built_in">print</span>((s_1+<span class="string">&#x27; &#x27;</span>)*3)<span class="comment">#&gt;&gt;&gt; hello hello hello</span></span><br><span class="line"><span class="built_in">print</span>(s_2*2) <span class="comment">#&gt;&gt;&gt;[1, 2, 3, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="模运算-取余运算"><a href="#模运算-取余运算" class="headerlink" title="% 模运算 取余运算"></a>% 模运算 取余运算</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5/4 商1余下1</span><br><span class="line"><span class="built_in">print</span>(5%4)<span class="comment">#&gt;&gt;&gt;:1</span></span><br><span class="line">5/3 商1余2</span><br><span class="line"><span class="built_in">print</span>(5%3)<span class="comment">#&gt;&gt;&gt;2</span></span><br><span class="line"><span class="built_in">print</span>(5/4)<span class="comment">#&gt;&gt;&gt;1.25</span></span><br></pre></td></tr></table></figure><p>作用：判断奇数偶数的<br>例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = int(input(<span class="string">&quot;请输入一个整数：&quot;</span>))<span class="comment">#一定要定义函数数据类型（格式化# ）</span></span><br><span class="line"><span class="keyword">if</span> x &lt;= 0:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入大于0的整数！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y = x%2</span><br><span class="line">    <span class="keyword">if</span> y == 0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;您输入的是偶数&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;您输入的是奇数&quot;</span>)</span><br><span class="line"></span><br><span class="line">x%2的值是0 则说明x是偶数</span><br><span class="line">x%2的值为1 则说明x是奇数</span><br></pre></td></tr></table></figure><p>判断数据类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">number = int(input(<span class="string">&quot;请输入一个数字：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(number) == int:</span><br><span class="line">    <span class="keyword">if</span> number == 0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请输入大于0的整数！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result1 = number%2</span><br><span class="line">        <span class="keyword">if</span> result1 == 0:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;您输入的是偶数&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;您输入的是奇数&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您输入的不是正整数！&quot;</span>)</span><br><span class="line"><span class="comment">#-----以上代码有个很大的问题，input()输出的值的数据类型为字符串，所以即使输入的是2，2的数据类型不是int，而是str</span></span><br><span class="line"></span><br><span class="line">nub = int(input())</span><br><span class="line">practise：上述的循环没有有效的判断出数据的类型，尝试判断数字是正数还是负数</span><br></pre></td></tr></table></figure><h3 id="比较（关系）运算符："><a href="#比较（关系）运算符：" class="headerlink" title="比较（关系）运算符："></a>比较（关系）运算符：</h3><p>6种比较关系：&gt;,&gt;=,&lt;,&lt;=,==,!=</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nub1 = 10</span><br><span class="line">nub2 = 2</span><br><span class="line"><span class="built_in">print</span>(nub1 &gt; nub2)<span class="comment">#&gt;&gt;&gt;True</span></span><br><span class="line"><span class="built_in">print</span>(nub1 &gt;= nub2)<span class="comment">#&gt;&gt;&gt;True</span></span><br><span class="line"><span class="built_in">print</span>(nub1 == nub2)<span class="comment">#&gt;&gt;&gt;False</span></span><br><span class="line"><span class="built_in">print</span>(nub1 != nub2)<span class="comment">#&gt;&gt;&gt;True</span></span><br><span class="line"><span class="built_in">print</span>(nub1 &lt; nub2)<span class="comment">#&gt;&gt;&gt;False</span></span><br><span class="line"><span class="built_in">print</span>(nub1 &lt;= nub2)<span class="comment">#&gt;&gt;&gt;False</span></span><br></pre></td></tr></table></figure><p>python是区分大小写的！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;get&#x27;</span> == <span class="string">&#x27;Get&#x27;</span>)<span class="comment">#&gt;&gt;&gt;False</span></span><br><span class="line"><span class="built_in">print</span>(False == 0)<span class="comment">#&gt;&gt;&gt;True  0等同于False，1等同于True（主要用于判断语句）</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符 = += -="></a>赋值运算符 = += -=</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=6</span><br><span class="line"><span class="built_in">print</span>(x)<span class="comment">#&gt;&gt;&gt;6</span></span><br><span class="line">y=1</span><br><span class="line">y+=1<span class="comment">#即y=y+1</span></span><br><span class="line"><span class="built_in">print</span>(y)<span class="comment">#&gt;&gt;&gt;2</span></span><br><span class="line">z=3</span><br><span class="line">z-=1<span class="comment">#即z=z-1&gt;&gt;&gt;2</span></span><br><span class="line"><span class="built_in">print</span>(z)<span class="comment">#&gt;&gt;&gt;2</span></span><br></pre></td></tr></table></figure><h2 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h2><p>if 判断条件:<br>    执行语句….<br>else:<br>    执行语句….</p><p>if 判断语句1:<br>    执行语句1….<br>elif 判断语句2:<br>    执行语句2….<br>else:<br>    执行语句3….</p><p>for example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">score = 90</span><br><span class="line"><span class="keyword">if</span> score &gt;=90:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;优秀！&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= 80:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;良好！&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;=60:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;及格&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;不及格&#x27;</span>)</span><br></pre></td></tr></table></figure><p>if条件判断语句里面，一定会有if开头，如果是多重判断我们可以引用elif 最后一种默认处理<br>但是else elif都不是必须的，根据业务场景<br>if, elif后面必须加判断条件<br>else后面不能加判断条件</p><p>练习：利用random函数生成随机整数，从1-9取出来，然后输入一个数字，来猜，如果大于，则打印bigger。小了，则打印less</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">random.randint(1,10) <span class="comment">#产生 1 到 10 的一个整数型随机数 </span></span><br><span class="line">random.random()         <span class="comment">#产生 0 到 1 之间的随机浮点数</span></span><br><span class="line">random.choice(<span class="string">&#x27;tomorrow&#x27;</span>)  <span class="comment">#从序列中随机选取一个元素</span></span><br><span class="line">random.randrange(1,100,2)  <span class="comment">#生成从1到100的间隔为2的随机整数</span></span><br><span class="line"></span><br><span class="line">import random <span class="comment">#一定要写这个</span></span><br><span class="line">r = random.randint(1,9)</span><br><span class="line">NUM = int(input(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> NUM &gt; r:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bigger&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> NUM == r:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;less&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>用于遍历一个集合<br>基本形式:<br>for 变量 in 集合：<br>    执行语句</p><p>for 变量 in 集合：<br>    执行语句1<br>else:<br>    执行语句2<br>通常与range()函数一起使用，range()返回一个列表，for…in…遍历这个列表中的元素<br>for example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(10):</span><br><span class="line"><span class="built_in">print</span>(“循环10次”)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(-1,2):</span><br><span class="line"><span class="keyword">if</span> x &gt; 0:</span><br><span class="line"><span class="built_in">print</span>(“正数:”,x)</span><br><span class="line"><span class="keyword">elif</span> x == 0:</span><br><span class="line"><span class="built_in">print</span>(“零”,o)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(“负数”,x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(“循环结束”)</span><br></pre></td></tr></table></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>while循环：用于循环执行程序，在某个条件下，循环执行某段程序，以处理需要重复处理的相同任务。<br>基本形式：<br>while 判断条件：<br>执行语句….</p><p>判断条件：可以是比较，逻辑，成员，True，False 0，1，非空数据，空数据<br>最终要的依据:判断条件的结果，到底是True 还是False<br>执行逻辑，先判断条件，再根据条件的值，决定是否要执行下面的代码块<br>执行完毕 会再次判断while后面的条件，决定是否要执行下面的代码块<br>True 死循环<br>False 不会执行while下面的代码块<br>0 就相当于False，所以不会执行while下面的代码<br>1 相当于True，会进入死循环<br>[]/{}/()/‘’ 不会执行while下面的代码#即为False<br>[1]/(1,2)/{“name”:”python”}  死循环#即为True<br>什么也不填 报错。while后面必须要填写一个条件</p><p>综上所述，while后面的条件一直为真，则会陷入死循环；同理，条件一直为False则永远不进入循环体内</p><p>如何防止进入死循环以及无法进入while循环呢<br>解决方案：<br>1.while后面的条件不为恒定值：让while后面的条件随着循环执行的次数变化而变化<br>    1)引入变量，并在内部实现变量的递增或递减<br>    2)变量与while后面的条件相结合</p><p>2.while后面的条件为恒定值<br>    1)引入continue 和 break<br>    2)添加内部判断条件</p><p>9.break&amp;continue </p><p>practice：<br>我要循环三次<br>变量自减，在恒定true的情况下，在循环的内部添加判断条件，达到可控的循环（避免死循环）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">count=3</span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这个是python_while循环条件下的语句&#x27;</span>)</span><br><span class="line">    count -=1<span class="comment">#每执行一次都会减1</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    <span class="keyword">if</span> count&gt;0:</span><br><span class="line">        <span class="built_in">continue</span><span class="comment">#结束本次循环，继续下一次循环</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">break</span><span class="comment">#结束循环</span></span><br></pre></td></tr></table></figure><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>知识点：<br>try…except…finally语句<br>raise语句<br>assert语句<br>自定义异常<br>程序调试<br>在python3中，BaseException是所有异常的基类，所有的内置异常都是它的派生类。用户自定义的异常也应该继承它。常见内部异常：<br>1.AssertionError&gt;assert语句失败时出发；<br>2.AttributeError&gt;属性引用和属性赋值异常<br>3.ImportError&gt;导入异常，点那个import语句或from语句无法再模块中找到相应文件名称时触发<br>4.NameError&gt;名称异常，在局部或全局空间中无法找到文件名称时触发<br>5.SyntaxError&gt;语法错误<br>6.SystemError&gt;编译器内部错误<br>7.TypeError&gt;当操作或者函数应用找不到合适的类型时触发</p><h3 id="try…except…"><a href="#try…except…" class="headerlink" title="try…except…"></a>try…except…</h3><pre><code>try:#尝试读取一个不存在的文件    open(“hello.txt”,“r”)except FileNotFoundError:#捕获FileNotFoundError异常    print(“文件不存在”)excrpt:#    其他异常情况    print(“程序异常”)</code></pre><p>异常处理语也可以嵌套：<br>    try:<br>        s =“hello”<br>        try:<br>            print()<br>            print()<br>        Except TypeError:<br>            Print(“字符串不支持减法运算”)<br>    except:<br>        Print(“异常”)<br>attention：若外层try子句中的代码块引发异常，程序将直接跳转到外层try对应的except子句，而内部的try语句不会被执行。<br>    try:<br>        执行语句<br>    except FileNotFoundError:#捕获指定异常<br>        执行语句<br>finally:#无论异常是否发生finally子句都会被执行<br>    执行语句</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="什么是文件？"><a href="#什么是文件？" class="headerlink" title="什么是文件？"></a>什么是文件？</h3><p>文件是数据的集合和抽象<br>文件类型：1.文本文件；2.二进制文件<br>文件本质上都是存储在存储器上的二进制数据</p><h3 id="字符编码："><a href="#字符编码：" class="headerlink" title="字符编码："></a>字符编码：</h3><p>1.ascii码—最先发明的字符编码（一个字符占据一个字节）；<br>2.gb2312:简体中文字符集；<br>3.gbk（对gb2312的优化）；<br>4.unicode：纳入世界上所有符号，但是效率不高；<br>5.utf-8:为了提高unicode效率，现在最常用的编码方式</p><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h3><p>指定处理模式，设置打开的文件为只读，只写，或可读写状态。<br>open(file,mode=’’,buffering=-1,encoding=None,errors=None,newline=None,closed=True,opener=None)<br>参数：<br>file-&gt;预打开的文件名，若文件不存在，open()将创建文件，如“test.txt”or 指定文件放置的位置“/user/Desktop/test.txt”<br>    mode-&gt;文件的打开模式，<br>“r”-&gt;以只读的方式打开文件；<br>“r+” -&gt;以读写的方式打开文件;<br>“w”-&gt;以写入的方式打开文件;删除文件内容，重新写入，若文件不存在则新建文件<br>“w+” -&gt;以读写的方式打开文件;删除文件内容，重新写入，若文件不存在则新建文件<br>“a” -&gt;;以写入的方式打开文件，在文件末尾追加新的内容，若文件不存在则新建文件<br>“a+” -&gt;;以读写的方式打开文件，在文件末尾追加新的内容，若文件不存在则新建文件<br>“b” -&gt;;以二进制模式打开文件，可与r，w，a，结合使用<br>“U” -&gt;支持所有换行符号。“\r”,”\n”,”\r\n”都表示换行</p><p>和mode组合的字符：<br>“b”二进制模式，例如：“rb”表示二进制读取<br>“t”文本模式（默认），例如：rt一般省略t<br>“+”读取写入，例如“r+”表示同时读写</p><p>1.基本操作：<br>创建一个名为test.txt的文本文件，（注意编码方式）文件中写入一下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窗前明月光，疑是地上霜。举头望明月，低头思故乡。</span><br></pre></td></tr></table></figure><p>打开文件mode = rt,t可以省略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fb = open(‘test.txt’，‘r’，encoding=‘utf-8’)</span><br><span class="line"><span class="comment">#读取</span></span><br><span class="line">content = fb.read()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line"><span class="comment">#关闭文件</span></span><br><span class="line">fb.close()</span><br></pre></td></tr></table></figure><p>attention:上面这种操作经常因为忘记关闭文件句柄，造成资源浪费，所以处理文件是往往使用with语句进行上下文管理。</p><p>2.with上下文管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(‘test.txt’，‘r’，encoding= ‘utf-8’)  as fb:</span><br><span class="line">content = fb.read()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>3.逐行读取readline<br>从文件中读取一行，如果f.readline()返回一个空的字符串，表示已经达到了文件末尾</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(‘test.txt’，‘r’，encoding= ‘utf-8’)  as fb:</span><br><span class="line"><span class="built_in">print</span>(fb.readline())</span><br></pre></td></tr></table></figure><p>readlines&gt;&gt;&gt;以列表形式返回所有行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(‘test.txt’，‘r’，encoding= ‘utf-8’)  as fb:</span><br><span class="line">content = fb.readlines()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>迭代:要从文件中读取行，也可以循环遍历文件对象，这使内存高效，快速的，并简化代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(‘test.txt’，‘r’，encoding= ‘utf-8’)  as fb:</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fb:</span><br><span class="line"><span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><p>4.读二进制文件<br>任何文件都可以以二进制读的方式打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(‘test.txt’，‘rb’)  as fb:</span><br><span class="line">content = fb.read()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>mode = rb，不需要encoding参数</p><p>5.写文本文件_清除写w</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">with open(path,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) as f:</span><br><span class="line">f.write(name + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        f.writelines(text)</span><br><span class="line">        f.write(<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">w会清除原文件内容重新写入</span><br><span class="line"></span><br><span class="line">6.写文本文件_追加写_a</span><br><span class="line"></span><br><span class="line">7.写文本文件_排他写x：当写入的文件存在则不创建，报错-&gt;&gt;&gt;file exists：‘test.txt’</span><br><span class="line"></span><br><span class="line">8.写二进制文件：wb；这种模式下写入内容为字节数据</span><br><span class="line"></span><br><span class="line">9.文件指针：open函数返回的文件对象使用文件指针来记录当前在文件中的位置</span><br><span class="line"></span><br><span class="line">10.read方法：在读模式下，使用文件对象的<span class="built_in">read</span> 方法可以读取文件的内容，接受一个整数参数表示读取内容的大小，文本模式下表示字符数量，二进制模式下表示字节大小。</span><br><span class="line">``` bash</span><br><span class="line">with open(‘test.txt’，‘r’，encoding= ‘utf-8’)  as fb:</span><br><span class="line">content = fb.read(3)</span><br><span class="line"><span class="comment">#&gt;床前明</span></span><br></pre></td></tr></table></figure><p>11.tell方法：返回整数，表示文件指针距离文件开头的字节数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with open(‘test.txt’，‘r’，encoding= ‘utf-8’)  as fb:</span><br><span class="line"><span class="built_in">print</span>(fb.tell())<span class="comment">#&gt;&gt;&gt;0</span></span><br><span class="line">content = fb.read(3)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line"><span class="built_in">print</span>(fb.tell())<span class="comment">#&gt;&gt;&gt;9</span></span><br></pre></td></tr></table></figure><p>12.seek方法：移动文件句柄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seek(offset= ;<span class="built_in">whence</span>=0)</span><br><span class="line">offset：偏移指针的字节数</span><br><span class="line"><span class="built_in">whence</span>：表示便宜参考，默认为0</span><br><span class="line">0&gt;&gt;&gt;表示偏移参考文件的开头，offset必须是=&gt;0的整数</span><br><span class="line">1&gt;&gt;&gt;表示偏移参考当前位置，offset可以是负数</span><br><span class="line">2&gt;&gt;&gt;表示偏移参考文件的结尾，offset一般是负数</span><br></pre></td></tr></table></figure><h2 id="模块-model-amp-包-packge-amp-函数-function"><a href="#模块-model-amp-包-packge-amp-函数-function" class="headerlink" title="模块(model)&amp;包(packge)&amp;函数(function)"></a>模块(model)&amp;包(packge)&amp;函数(function)</h2><h3 id="模块概念"><a href="#模块概念" class="headerlink" title="模块概念"></a>模块概念</h3><p>模块是一个包含python定义和语句的文件，文件名就是模块名后跟文件后缀.py<br>（一个文件即一个模块）</p><pre><code>导入模块1：import 模块名for example:import requests;使用模块中的函数：（在导入模块前提下）res = requests.get(url=,headers=,params=)此方法：当前变量表中，不会直接定义导入的模块的函数名，他只定义了模块名，所以使用函数则是通过模块名访问函数导入模块2：from 模块名 import 函数名For example:from fibo import fib,fib2此方法：并不会把被调模块引入当前的变量表中，而是将函数fib，fib2引入，可直接访问两个函数导入模块3：from 模块名 import *此方法：导入模块中定义的所有名称（函数名，变量，类名）导入模块4：from 模块名 as 新名称            from 模块名 import 名称 as 新名称</code></pre><h3 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h3><p>模块的问题解决了代码过长不便于维护的问题，为避免模块名冲突，python又引入了用目录来组织模块的方法，包<br>for example:创建名为my_package的文件夹，将模块my_model.py放入该文件夹下，则可通过import my_package.my_model 来引入，目的：避免程序中不同包下存在不同的模块，避免引入模块时冲突。</p><h3 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h3><p>具备一定功能，可重复使用的语句，用函数名来表示并通过函数名进行调用，每次使用函数可以提供不同的参数作为输入，以实现对不同数据的处理。</p><h4 id="函数调用的过程"><a href="#函数调用的过程" class="headerlink" title="函数调用的过程"></a>函数调用的过程</h4><p>1.调用程序在调用处暂停执行；<br>2.在调用时将实参赋值给函数的形参；<br>3.执行函数体语句；<br>4.函数调用结束给出返回值，程序回到调用前的暂停处继续执行<br>def -&gt;&gt;python中定义函数的关键字<br>def 函数名(参数列表)：<br>    函数体<br>    return 返回值列表</p><h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><h5 id="形参："><a href="#形参：" class="headerlink" title="形参："></a>形参：</h5><p>必须参数：定义函数时，调用者必须传递实参给这个形参，他就是必须参数，直接定义在函数名后()中的形参就是必须参数。<br>默认参数：定义函数时，某些形参可能在调用时不用接收实参，这种情况可以定义为默认参数，在函数名后()，以参数名=默认值的形式定义的形参就是必须参数，默认参数必须定义在必须参数的后面<br>For example:定义一个函数，它接收两个参数content和times，content是函数需要打印的内容，times是函数打印的次数，若不传递times则默认打印一次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def my_print(content,<span class="built_in">times</span>=1):  <span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">times</span>):</span><br><span class="line">Print(content)</span><br><span class="line">my_print(‘happy birthday!’)<span class="comment">#调用，不写入times值</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; happy birthday!</span></span><br><span class="line">my_print(‘happy birthday!’,2)  <span class="comment">#调用，指定times值</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; happy birthday!</span></span><br><span class="line"> happy birthday!</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 不定参数</span></span><br><span class="line">在定义函数时，不确定在调用时会传递多少个实参，可定义不定参数</span><br><span class="line">位置不定参数：</span><br><span class="line">在形参前加*号可以定义位置不定参数，通常定义为*args</span><br><span class="line">用来接收函数调用时，以位置参数传递过来的超过形参数量的多余的参数</span><br><span class="line">不定参数必须定义在默认参数后面</span><br><span class="line"><span class="keyword">for</span> example:</span><br><span class="line">``` bash</span><br><span class="line">def add(x,y,*args):</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">x += i</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">add(1,2,3,4)<span class="comment">#&gt;&gt;&gt; 10</span></span><br></pre></td></tr></table></figure><h5 id="关键字不定参数"><a href="#关键字不定参数" class="headerlink" title="关键字不定参数"></a>关键字不定参数</h5><p>在形参前加<strong>号可以定义关键字不定参，通常定义为</strong>kwargs<br>用来接收函数调用时，以关键字参数传递过来的超过形参的多余的实参<br>for example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def func(a,**kwargs):</span><br><span class="line"><span class="built_in">print</span>(kwargs,<span class="built_in">type</span>(kwargs))</span><br><span class="line">func(a=1,b=2,c=3,d=4)</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;&#123;‘b’=2,’c’= 3,’d’=4&#125;&lt;class’dict’&gt;</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 实参：</span></span><br><span class="line">1.位置参数：调用函数时，传递实参时默认会按照形参的位置一一对应，这种实参传递叫做位置参数</span><br><span class="line"><span class="keyword">for</span> example:</span><br><span class="line">``` bash</span><br><span class="line">def my_power(x,n):</span><br><span class="line"><span class="built_in">print</span>(x**n)<span class="comment">#x的n次幂</span></span><br><span class="line">my_power(3,2)</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;9</span></span><br></pre></td></tr></table></figure><p>2.关键字参数：调用函数时，传递实参时以 形参名=实参 的形式传递参数，叫做关键字参数<br>for example:<br>调用上方函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_power(x=2,n=3)</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;8</span></span><br></pre></td></tr></table></figure><ol start="3"><li>*；**在传递实参时的用法</li></ol><p><em>解包：在传递实参的时候，可以通过</em>对迭代对象(列表)进行解包<br>for example：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def fun(a,b,*arg):</span><br><span class="line">fun(*ls)<span class="comment">#&gt;&gt;&gt;1 2 (3, 4, 5, 6)</span></span><br></pre></td></tr></table></figure><p><strong>解包：在传递实参时候，可以通过</strong>对字典对象进行解包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def fun(a,b,**kwargs):</span><br><span class="line">    <span class="built_in">print</span>(a,b,kwargs)</span><br><span class="line">dic = &#123;<span class="string">&#x27;a&#x27;</span>:1,<span class="string">&#x27;b&#x27;</span>:2,<span class="string">&#x27;c&#x27;</span>:3,<span class="string">&#x27;d&#x27;</span>:4&#125;</span><br><span class="line">fun(**dic)<span class="comment">#&gt;&gt;&gt;1 2 &#123;&#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br></pre></td></tr></table></figure><h5 id="返回值return"><a href="#返回值return" class="headerlink" title="返回值return"></a>返回值return</h5><p>Python中使用return关键字来退出函数，返回到函数被调用的地方继续往下执行<br>函数中可以没有返回值，也就是说函数中可以没有return语句，这时函数返回None<br>for example：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def add(x,y,*args):</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">x += i</span><br><span class="line"><span class="built_in">return</span> x </span><br><span class="line">res = add(1,2)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;3</span></span><br></pre></td></tr></table></figure><h4 id="Lambdah函数"><a href="#Lambdah函数" class="headerlink" title="Lambdah函数"></a>Lambdah函数</h4><p>用来定义简单的，可以在一行内表示的函数(用的少)<br>语法格式：lambda arg1,arg2,… : expression</p><h4 id="变量作用域：局部变量；全局变量"><a href="#变量作用域：局部变量；全局变量" class="headerlink" title="变量作用域：局部变量；全局变量"></a>变量作用域：局部变量；全局变量</h4><p>global关键字：有时候需要在函数内部修改全局变量。使用globals关键字可以在函数内部修改全局变量</p><p>for example：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">def fun():</span><br><span class="line">global a </span><br><span class="line">a += 1</span><br><span class="line">fun()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结的python基础语法，必须熟记和使用&lt;br&gt;(持续完善)&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>jmeter非GUI操作流程</title>
    <link href="http://example.com/2021/12/13/JMeter%E9%9D%9Egui%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2021/12/13/JMeter%E9%9D%9Egui%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/</id>
    <published>2021-12-12T16:02:57.000Z</published>
    <updated>2021-12-19T13:57:35.999Z</updated>
    
    <content type="html"><![CDATA[<p>工作中曾接触和使用到的压测方式</p><span id="more"></span><p>服务器上环境搭建<br>1.jmeter 版本：apache-jmeter-5.2.1<br>2.插件：serverAgent-2.2.3<br>默认端口：4444<br>重新分配端口：./startAgent.sh –tcp-port  3307 –udp-port 3308 –sysinfo<br>3.本地写好步骤<br>4.使用filezilla将写好的脚本上传至服务器（注意ip和端口使用内网ip+端口，注意区分管理系统后台还是小程序后台，测试IP：172.19.40.211;端口：8082（管理系统后台）；8081（小程序后台））<br>5.执行脚本：jmeter -n -t tuangou_test02.jmx -l test004.jtl -e -o tuangoutestreport<br>6.将 tuangoutestreport下载至本机使用html打开<br>7.mysql数据库查询最大连接数：show variables like ‘max_connections’<br>8.修改mysql数据库最大连接数：set global max_connections = 151;<br>9.服务器上查看运行中的端口号：netstat -ntlp<br>10.运行serverAgent：./startAgent.sh 或者 nohup ./startAgent.sh &amp; ，把Agent服务放到后台并且不挂起。<br>11.使配置文件生效:source profile<br>12.jtl文件的查看方式，gui界面下，使用查看结果树，聚合报告<br>13.从数据库中导出用户数据<br>14.使用插件PerfMon Metrics Collector进行服务器资源监控，在进行非gui执行之前需要配置输出的file，注意不能与最终输出的测试结果jtl文件相同，可以是csv也可以是jtl文件</p><p>防火墙相关操作<br>1 、防火墙关闭 -ping 得通<br>firewall-cmd –add-port=4444/tcp –permanent ## 永久添加 4444 端⼝<br>firewall-cmd –list-ports ## 列出开放的端⼝<br>systemctl stop firewalld ## 关闭防火墙<br>systemctl start firewalld ## 开启防火墙<br>systemctl status firewalld ## 查看防火墙状态<br>systemctl restart firewalld ## 重启防火墙</p><p>netstat -tunlp##查看端口占用</p>]]></content>
    
    
    <summary type="html">工作中曾接触和使用到的压测方式</summary>
    
    
    
    
    <category term="jmeter" scheme="http://example.com/tags/jmeter/"/>
    
  </entry>
  
</feed>
